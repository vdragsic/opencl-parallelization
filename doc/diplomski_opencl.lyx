#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language croatian
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family sfdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "Veljko Dragsic,,," 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\align center
SVEUČILIŠTE U ZAGREBU
\begin_inset Newline newline
\end_inset


\series bold
FAKULTET ELEKTROTEHNIKE I RAČUNARSTVA
\series default

\begin_inset VSpace 6cm
\end_inset


\end_layout

\begin_layout Standard
\align center
DIPLOMSKI RAD
\end_layout

\begin_layout Standard
\align center

\series bold
\size largest
Paralelizacija algoritama na heterogenim platformama uz pomoć sustava OpenCL
\end_layout

\begin_layout Standard
\align center
Veljko Dragšić
\begin_inset Newline newline
\end_inset

Voditelj: Domagoj Jakobović
\begin_inset VSpace 10cm
\end_inset


\end_layout

\begin_layout Standard
\align center
Zagreb, Veljača, 2010.
\change_inserted 0 1266849891

\lang english

\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 0 1266849891


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Uvod
\end_layout

\begin_layout Subsection
Paralelni algoritmi
\end_layout

\begin_layout Standard
Uobičajen način razmišljanja o radu procesora je da slijedno prolazi kroz
 tekst programa odnosno njegov strojni jezik i izvršava naredbe.
 Prilikom oblikovanja algoritama također razmišljamo na taj način, tj.
 izrađujemo slijedni algoritam.
 Ako je slijedni algoritam procesorski prezahtjevan, odnosno ako bi se predugo
 izvršavao na jednom procesoru, nameće se potreba da se on paralelizira
 kako bi se mogao izvršavati na više procesora ili računala istovremeno,
 te se na taj način ubrzati.
 Paralelizacija algoritama može biti trivijalna, ali i izrazito kompleksna,
 ovisno o samom problemu koji se želi riješiti; stoga postoje i različiti
 načini paralelizacije.
 Ponekad nije moguće neki problem u potpunosti paralelizirati, pa onda govorimo
 o slijednom i paralelnom dijelu algoritma, a o tome ovisi i ubrzanje koje
 se može postići (veći udio paraleliziranog dijela podrazumijeva i veće
 ubrzanje).
 Kako algoritmi postaju sve zahtjevniji i kompleksniji, a procesori sadrže
 nekoliko jezgri i mnogo logike koja pospješuje paralelnu izvedu naredbi,
 tako se i nameće sve veća potreba za paralelizacijom algoritama i posla
 koje obavljamo na računalu.
\end_layout

\begin_layout Subsection
Heterogene platforme
\end_layout

\begin_layout Standard
Pojam heterogene platforme podrazumijeva mikroprocesore različitih namjena
 i arhitektura.
 Do sredine '90-ih godina prošlog stoljeća smo u osobnim računalima imali
 samo centralne mikroprocesore (engl.
 central processing unit, CPU), a kasnije su im se pridružili i grafički
 mikroprocesori (engl.
 graphics processing unit, GPU) ponajviše specijalizirani za ubrzavanje
 prikaza trodimenzionalne grafike.
 Kroz vrijeme su se proširivali setovi instrukcija, broj bitova sa kojima
 barataju je skočio sa 32 na 64, pojavljivale su se nove arhitekture, radni
 takt je rastao dok nije naišao na fizička ograničenja postojeće tehnologije
 izrade, da bi se zatim pojavili višejezgreni mikroprocesori.
 Danas su nam na raspolaganju višejezgreni centralni mikroprocesori opće
 namjene, visokoparalelizirani grafički procesori i mnoštvo mikroprocesora
 specifičnije namjene koje nalazimo u lako dostupnim igračim konzolama pa
 sve do specijaliziranih poslužitelja.
 Logično se javlja potreba za što učinkovitijim i lakšim iskorištavanjem
 potencijala mikroprocesora različitih arhitektura.
\end_layout

\begin_layout Subsection
OpenCL
\end_layout

\begin_layout Standard

\emph on
Open Computing Language
\emph default
 (kraće: 
\emph on
OpenCL
\emph default
) je sustav koji omogućava jednostavniju paralelizaciju algoritama i njihovo
 izvođenje na heterogenim platformama.
 
\emph on
OpenCL
\emph default
 se sastoji od programskog jezika baziranog na C-u (ISO C99) i sučelja za
 pristup hardverskim platformama.
 Kroz navedeni princip se prvo oblikuje željeni algoritam koji zovemo programska
 jezgra (
\shape italic
\emph on
engl
\emph default
.
 kernel
\shape default
), a zatim se izvodi u postavljenoj okolini na na dostupnim platformama,
 poput centralnog ili grafičkog mikroprocesora.
 Bitno je napomenuti da je 
\shape italic
OpenCL
\shape default
 prvi sustav koji omogućuje da se isti tekst programa, točnije programska
 jezgra, izvodi paralelno na različitim platformama, što je upravo i njegova
 glavna prednost.
 Projekt je krajem 2008.
 godine inicijalno započela tvrtka 
\emph on
Apple inc.
\emph default
, dok je prva potpuna implementacija postala dostupna u operacijskom sustavu
 
\emph on
Mac OS X
\emph default
 u kolovozu 2009.
 godine.
 Upravljanje projektom je kasnije prepušteno konzorciju 
\emph on
Khronos
\emph default
 koji okuplja gotovo sve značajne IT kompanije u tom području, a specifikacija
 standarda je otvorenog tipa.
\end_layout

\begin_layout Subsection
Zadatak rada
\end_layout

\begin_layout Standard
Opis i upoznavanje sa sustavom 
\emph on
OpenCL
\emph default
 je primarni zadatak ovog rada.
 Pomoću sustava se na praktičnim primjerima treba ispitati složenost paralelizac
ije algoritama za heterogene platforme, uzimajući u obzir određene optimizacije
 za pojedine platforme.
 Također se pri analizi sustava uzima u obzir učinkovitost, performanse,
 dostupne implementacije i podržane platforme.
 Analiza sustava uključuje i usporedbu sa drugim tehnologijama za paralelizaciju
, te isticanje prednosti i mana 
\emph on
OpenCL
\emph default
-a.
 Rad nije samo usmjeren na sustav samo sa softverske strane, već će predočiti
 opis i usporedbu hardverskih platformi koje su danas dostupne, ali i onih
 koje tek možemo očekivati u skorijoj budućnosti.
 Na temelju rezultata ispitivanja u 
\emph on
OpenCL
\emph default
-u na dostupnim platformama, iznijet će se okvirne smjernice o opremanju
 računala namijenjenog izvedbi paralelnih algoritama, uzimajući u obzir
 procesorsku snagu, učinkovitost i cijenu.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Open Computing Language
\end_layout

\begin_layout Subsection
Uvod
\end_layout

\begin_layout Standard

\emph on
OpenCL
\emph default
 je nastao s ciljem olakšavanja paralelizacije algoritama i omogućavanja
 njihovog izvršavanja na različitim platformama.
 Dok se do prije nekoliko godina za procesorski zahtjevne algoritme oslanjalo
 isključivo na centralne mikroprocesore opće namjene, s vremenom su ih po
 performansama i kompleksnosti dostigli specijalizirani grafički mikroprocesori.
 Različita namjena podrazumijeva i različite arhitekture mikroprocesora,
 stoga tekst programa nije moguće jednostavno prenositi između dvije poprilično
 različite arhitekure.
 Glavna značajka grafičkih mikroprocesora je određena što bržim prikazom
 trodimenzionalne grafike, a to je zapravo paralelno obavljanje istovjetnih
 matematičkih operacija na velikoj količini podataka.
 Uslijedilo je iskorištavanje njihovog potencijala i u općenitije svrhe,
 nazvano 
\shape italic
General Purpose computing on Graphics Processing Units
\shape default
, 
\shape italic
GP/GPU
\shape default
.
 Glavni proizvođači grafičkih mikroprocesora su pružili sučelja za njihovo
 iskorištavanje, 
\emph on
Nvidia inc.

\emph default
 tehnologiju zvanu 
\emph on
CUDA
\emph default
, a 
\emph on
AMD/ATI
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
Kompanija 
\emph on
Advanced Micro Devices
\emph default
 (
\emph on
AMD
\emph default
) je 2006.
 godine preuzela 
\emph on
ATI Technologies Inc
\emph default
.
 
\emph on
AMD
\emph default
 je do onda bio drugi proizvođač x86 mikroprocesora, iza 
\emph on
Intela
\emph default
, a 
\emph on
ATI
\emph default
 se natjecao sa 
\emph on
Nvidiom
\emph default
 na području grafičkih mikroprocesora.
\end_layout

\end_inset

 pandan zvan 
\shape italic
ATI Stream.

\shape default
 Bilo je logično očekivati tehnologiju koja će omogučiti lakšu paralelizaciju
 algoritama i njihovo izvođenje na centralnom i/ili grafičkom mikroprocesoru.
 Upravo tu prazninu popunjava 
\emph on
OpenCL
\emph default
, koji omogućava da se jednom napisan tekst programa izvršava na različitim
 arhitekturama.
\end_layout

\begin_layout Standard
Idejni začetnik projekta je tvrtka 
\emph on
Apple
\emph default
, poznata po prodaji računala u kombinaciji sa svojim operacijskim sustavom
 
\emph on
Mac OS X
\emph default
 baziranim na 
\emph on
Unixu
\emph default
 odnosno 
\emph on
BSD
\emph default
-a
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
BSD
\emph default
, 
\emph on
Berkeley Software Distribution
\emph default
, je varijanta 
\emph on
Unix
\emph default
 operacijskog sustava nastala na sveučilištu Berkeley u SAD-u.
 Mnogi danas poznati operacijski sustavi se djelomično baziraju na njemu,
 od zatvorenog 
\emph on
Mac OS X
\emph default
-a do otvorenih 
\emph on
FreeBSD
\emph default
-a i 
\emph on
OpenBSD
\emph default
-a.
\end_layout

\end_inset

.
 Kako se kompanija bavi sklopovljem i programskom opremom bilo je u neku
 ruku prirodno za očekivati da će prva pokrenuti razvoj takvog sustava.
 U realizaciji projekta su osim 
\emph on
Applea
\emph default
 sudjelovale i kompanije 
\emph on
AMD/ATI
\emph default
, 
\emph on
IBM
\emph default
, 
\emph on
Intel
\emph default
 i 
\emph on
Nvidia
\emph default
.
 U srpnju 2008.
 godine je upravljanje daljnim razvojem 
\emph on
OpenCL
\emph default
-a prepušteno konzorciju 
\emph on
Khronos
\emph default
, koji je oformljen 2000.
 godine od strane kompanija koje se bave proizvodnjom grafičkog sklopovlja
 i multimedijom.
 
\emph on
Khronos Group
\emph default
 već upravlja razvojem nekih izrazito bitnih standarda u grafičkoj industriji,
 poput 
\emph on
OpenGL
\emph default
-a.
 Specifikacija 
\emph on
OpenCL
\emph default
-a je otvorena tako da ju bilo koji proizvođač može implementirati za svoje
 mikroprocesore.
 Danas u razvoju sudjeluju sve relevantnije kompanije na području računalne
 grafike i mikroprocesora, od proizvođača računalnih igara poput 
\emph on
Blizzarda
\emph default
 i 
\emph on
Electronic Artsa
\emph default
, pa sve do kompanija 
\emph on
ARM
\emph default
, 
\emph on
Ericsson
\emph default
, 
\emph on
General Electric
\emph default
, 
\emph on
Texas Instruments
\emph default
 i mnogih drugih.
\end_layout

\begin_layout Subsection
Implementacije i podržane platforme
\end_layout

\begin_layout Standard
U vrijeme pisanja ovog rada je bilo dostupno tek nekoliko implementacija,
 te je podržan manji broj platformi.
 Do sada su kompanije 
\emph on
AMD/ATI
\emph default
, 
\emph on
Nvidia
\emph default
 i 
\emph on
Via
\emph default
 barem djelomično podržali svoje mikroprocesore kroz upravljačke programe
 (
\shape italic
\emph on
engl.

\emph default
 drivers
\shape default
) koje izdaju.
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Podržane 
\emph on
OpenCL
\emph default
 platforme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="4.5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kompanija
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Podržane platforme
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OS
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AMD
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none" width="7.5cm">
\begin_inset Text

\begin_layout Plain Layout
ATI Radeon grafičke kartice s mikroprocesorima R700 i R800,
\end_layout

\begin_layout Plain Layout
AMD x86 mikroprocesori sa setom instrukcija SSE3
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none" width="4.5cm">
\begin_inset Text

\begin_layout Plain Layout
GNU/Linux,
\end_layout

\begin_layout Plain Layout
Mac OS X Snow Leopard,
\end_layout

\begin_layout Plain Layout
Windows XP, Vista, 7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nvidia
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none" width="7.5cm">
\begin_inset Text

\begin_layout Plain Layout
GeForce 8 i noviji grafički mikroprocesori,
\end_layout

\begin_layout Plain Layout
Quadro i Tesla grafički mikroprocesori
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none" width="4.5cm">
\begin_inset Text

\begin_layout Plain Layout
GNU/Linux,
\end_layout

\begin_layout Plain Layout
Mac OS X Snow Leopard,
\end_layout

\begin_layout Plain Layout
Windows XP, Vista, 7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Via
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ChromotionHD 2.0 video mikroprocesor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Kompanija 
\emph on
AMD
\emph default
 je u potpunosti implementirala 
\emph on
OpenCL
\emph default
 kroz svoj skup upravljačkih programa i 
\emph on
ATI Stream SDK 2.0
\emph default
 za operacijske sustave 
\emph on
GNU/Linux
\emph default
 i 
\emph on
Windows
\emph default
.
 
\emph on
Nvidia
\emph default
 je učinila isto kroz svoje upravljačke programe i 
\emph on
SDK
\emph default
 (
\shape italic
\emph on
engl.

\emph default
 Software Developers Kit
\shape default
).
 Appleov
\emph on
 Mac OS X
\emph default
 dolazi već sa potpunom implementacijom 
\emph on
OpenCL
\emph default
-a od verzije 
\emph on
Snow Leopard
\emph default
, u kojoj se i općenito pojavila prva potpuna implementacija.
 
\emph on
Intel
\emph default
 kao proizvođač najraširenijih mikroprocesora opće namjene još nije izdao
 nikakvu implementaciju, a također se čeka da i 
\emph on
IBM
\emph default
 izda podršku za svoje 
\emph on
Cell/BE
\emph default
 mikroprocesore
\begin_inset Foot
status open

\begin_layout Plain Layout
Cell mikroprocesor je nastao u suradnji IBM-a, Toshibe i Sonya, te se nalazi
 u Playstation 3 igračim konzolama.
 Mikroprocesor je zanimljive arhitekure je se sastoji od jedne jezgre općenite
 namjene, te nekoliko specijaliziranih vektorskih jezgri.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Zgodno je napomenuti kako se 
\emph on
AMD
\emph default
-ovi upravljački programi za centralne mikroprocesore mogu iskoristiti i
 za Intelove, jer su oba iste arhitekture, x86.
 Za to je u računalu potrebno imati 
\emph on
AMD
\emph default
-ovu grafičku karticu, jer upravljački programi za grafički i centralni
 mikroprocesor, a koji implementiraju 
\emph on
OpenCL
\emph default
, dolaze zajedno.
\end_layout

\begin_layout Standard
Kako su 
\emph on
AMD
\emph default
 i 
\emph on
Nvidia
\emph default
 već otprije omogućili GP/GPU na svojim grafičkim mikroprocesorima kroz
 sustave 
\emph on
Stream
\emph default
 i 
\emph on
CUDA
\emph default
, tako se 
\emph on
OpenCL
\emph default
 može smatrati samo nadogradnjom na njihove već postojeće tehnologije.
\end_layout

\begin_layout Standard
U ovom radu se za potrebe ispitivanja koristi implementacija PyOpenCL 
\begin_inset Foot
status open

\begin_layout Plain Layout
Dokumentacija projekta je dostupna na web adresi http://documen.tician.de/pyopencl
/, a glavna stranica projekta na http://mathema.tician.de/software/pyopencl
\end_layout

\end_inset

.
 
\emph on
PyOpenCL
\emph default
 omogućava pristupanje sučelju 
\emph on
OpenCL
\emph default
-a kroz programski jezik 
\emph on
Python
\emph default
, dok se programske jezgre i dalje programiraju u 
\emph on
OpenCL C
\emph default
-u.
 To svejedno ne isključuje potrebu za instaliranim upravljačkim programima
 za platforme koje želimo korisiti.
 Na taj način se osjetno skraćuje tekst programa potreban za izradu željene
 aplikacije i postavljanje okoline za izvođenje programskih jezgri, dok
 njihova brzina izvođenja na ciljanim platformama ostaje nepromijenjena.
\end_layout

\begin_layout Subsection
Opis sustava i osnovne funkcionalnosti
\end_layout

\begin_layout Standard

\emph on
Open Computing Language
\emph default
 je standard namijenjen paralelnom programiranju opće namjene na heterogenim
 platformama, pritom podrazumijevajući danas dostupne mikroprocesore različitih
 namjena i arhitektura, a velike računalne snage.
 Standard 
\emph on
OpenCL
\emph default
 cilja na područje od ugradbene (
\shape italic
\emph on
engl.

\emph default
 embedded
\shape default
) i potrošačke (
\shape italic
\emph on
engl.

\emph default
 consumer
\shape default
) programske opreme, pa sve do razine računarstva visokih performansi (
\shape italic
\emph on
engl.

\emph default
 High performance Computing, HPC
\shape default
).
 Sustav je zadržan na niskoj razini koja je blizu samog sklopovlja, što
 omogućuje postizanje izrazito dobrih performansi.
 Također je bitno da je apstrakcija koju sustav pruža prenosiva među platformama
, tako da se u budućnosti može očekivati njegova raširena primjena, pogotovu
 u području grafičkih, procesorski zahtjevnih i paralelnih aplikacija.
 U vrijeme pisanja rada nije bilo dostupnih aplikacija šire upotrebe iz
 razloga što je 
\emph on
OpenCL
\emph default
 kao tehnologija praktično postao dostupan tek u proteklih nekoliko mjeseci.
\end_layout

\begin_layout Standard
Standard 
\emph on
OpenCL
\emph default
 se sastoji od sučelja za pristup sklopovskim platformama, biblioteka i
 sustava za raspodjelu poslova, te prenosivog programskog jezika: 
\end_layout

\begin_layout Itemize
Podrška za paralelne programske modele bazirane na podjeli podataka i/ili
 zadataka
\end_layout

\begin_layout Itemize
Podskup programskog jezika ISO C99, proširen ekstenzijama za paralelizaciju
\end_layout

\begin_layout Itemize
Definira konzistentne numeričke zahtjeve bazirane na standardu IEEE 754
\end_layout

\begin_layout Itemize
Definira konfiguracijski profil za ručne i ugradbene uređaje
\end_layout

\begin_layout Itemize
učinkovito komunicira se tehnologijama 
\emph on
OpenGL
\emph default
 i ostalim sučeljima za pristup grafičkim karticama
\end_layout

\begin_layout Standard
Za korištenje 
\emph on
OpenCL
\emph default
-a nisu potrebna uobičajena grafička sučelja poput otvorenog 
\emph on
OpenGL
\emph default
-a ili Microsoftovog 
\emph on
DirectX
\emph default
-a, već sustav direktno komunicira sa sklopovljem putem upravljačkih programa
 proizvođača.
\end_layout

\begin_layout Subsection
Arhitektura OpenCL-a
\end_layout

\begin_layout Standard
Arhitektura OpenCL-a se sastoji od hijerarhije u nekoliko modela:
\end_layout

\begin_layout Itemize
platformski model,
\end_layout

\begin_layout Itemize
memorijski model,
\end_layout

\begin_layout Itemize
izvršni (
\shape italic
\emph on
engl.

\emph default
 execution
\shape default
) model,
\end_layout

\begin_layout Itemize
programski (
\shape italic
\emph on
engl.

\emph default
 programming
\shape default
) model.
\end_layout

\begin_layout Subsubsection
Platformski model
\end_layout

\begin_layout Standard

\emph on
OpenCL
\emph default
-ov platformski model se sastoji od domaćina (
\shape italic
\emph on
engl.

\emph default
 host
\shape default
) spojenog na jedno ili više računalnih uređaja (
\shape italic
\emph on
engl.

\emph default
 compute device
\shape default
).
 Svaki računalni uređaj može imati jednu ili više računalnih jedinica (
\shape italic
\emph on
engl.

\emph default
 computing unit
\shape default
), a svaka računalna jedinica jedan ili više procesirajućih elemenata (
\shape italic
\emph on
engl.

\emph default
 processing element
\shape default
).
 Procesirajući elementi barataju sa podacima za obradu.
 
\end_layout

\begin_layout Standard
Kako model djeluje previše apstraktno, ilustracija u stvarnosti bi bila
 da domaćina zamijenimo za naše stolno ili prenosivo računalo, koje zatim
 u sebi ima više računalnih uređaja, pritom misleći na jedan ili više centralnih
 ili grafičkih mikroprocesora, odnosno CPU-a i GPU-a.
 Svaki taj računalni uređaj može imati više računalnih jedinica, poput višejezgr
enih CPU koji su danas uobičajeni, te imaju po dvije, četiri ili čak više
 jezgri.
 GPU je ponešto drugačije arhitekture, te jedan mikroprocesor može imati
 na desetke jezgri, pa čak i stotine jezgri.
 Procesirajući element kod GPU-a odgovara dretvi (
\shape italic
\emph on
engl.

\emph default
 thread
\shape default
) koje on izvršava u velikom broju, čak i po nekoliko tisuća istovremeno.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/platform.png
	lyxscale 50
	width 14cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout

\emph on
OpenCL
\emph default
 platformski model
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aplikacija u 
\emph on
OpenCL
\emph default
-u se pokreće na domaćinu, koji priprema okolinu za izvođenje programskih
 jezgri, prenosi podatke računalnim uređajima, te zatim pokreće izvođenje
 programskih jezgri na procesirajućim elementima.
 Procesirajući elementi prilikom rada djeluju po 
\emph on
SIMD
\emph default
 principu (
\shape italic
\emph on
engl.

\emph default
 Single Instruction, Multiple Data
\shape default
).
\end_layout

\begin_layout Subsubsection
Memorijski model
\end_layout

\begin_layout Standard
Memorijski model standarda 
\emph on
OpenCL
\emph default
 raspoznaje četiri memorijska područja, a radna jedinica koja izvršava programsk
u jezgru može pristupiti svakoj od njih.
\end_layout

\begin_layout Itemize

\series bold
Globalna memorija
\series default
: Sve radne jedinice, neovisno u kojoj se radnoj grupi nalaze, mogu pisati
 ili čitati iz bilo koje lokacije globalne memorije.
 Fizički globalna memorija odgovara radnoj memoriji (engl.
 
\emph on
Random access memory, RAM
\emph default
) uređaja.
 Točnije u slučaju CPU-a je to radna memorija na matičnoj ploči, a kod GPU-a
 je riječ o radnoj memoriji na grafičkoj kartici.
\end_layout

\begin_layout Itemize

\series bold
Konstantna memorija
\series default
: Područje globalne memorije koje ostaje nepromijenjeno za vrijeme izvođenja
 programskih jezgri.
 Za zauzimanje i stavljanje podataka u konstantnu memoriju brine se domaćin.
\end_layout

\begin_layout Itemize

\series bold
Lokalna memorija
\series default
: Memorijsko područje namijenjeno radnim jednicama koje se nalaze unutar
 iste radne grupe.
 Radne jedinice iz druge grupe joj ne mogu pristupati.
 Ovisno o 
\emph on
OpenCL
\emph default
 implementaciji i tipu uređaja, za lokalnu memoriju može biti rezerviran
 dio globalne memorije ili se mogu koristiti neka druga memorijska područja.
 U praksi lokalna memorija kod CPU-a i GPU-a odgovara njihovim pričuvnim
 memorijama (
\shape italic
\emph on
engl.

\emph default
 cache memory
\shape default
) koje se nalaze u samom mikroprocesoru.
 Pristup lokalnoj memoriji je značajno brži nego globalnoj memoriji, tako
 da se, uzimajući u obzir koju ćemo memoriju koristiti, može postići znatno
 ubrzanje prilikom pisanja algoritma.
 Količina pričuvne memorije je znatno manja kod GPU-a nego kod CPU-a.
\end_layout

\begin_layout Itemize

\series bold
Privatna memorija
\series default
: Područje memorije namijenjeno svakoj radnoj jedinici pojedinačno.
 Svaka radna jedinica ima pristup samo svojoj privatnoj memoriji.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/memory.png
	lyxscale 50
	width 14cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
OpenCL
\emph default
 memorijski model
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tablica 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:OpenCL-memorijski-model"

\end_inset

 prikazuje u kojem memorijskom području domaćin i programske jezgre mogu
 zauzimati (alocirati) memoriju.
 Podrazumijevaju se dva načina zauzimanja: statično, koje se odvija u vrijeme
 prevođenja programa i dinamično, u vrijeme izvođenja programa.
 Drugi redak svakog polja označuje mogučnost pisanja i čitanja iz memorije.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:OpenCL-memorijski-model"

\end_inset

OpenCL memorijski model
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features>
<column alignment="center" valignment="top" width="2cm">
<column alignment="center" valignment="top" width="3cm">
<column alignment="center" valignment="top" width="3cm">
<column alignment="center" valignment="top" width="3cm">
<column alignment="center" valignment="top" width="3cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Globalna
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Konstantna
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lokalna
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Privatna
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Domaćin
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none" width="3cm">
\begin_inset Text

\begin_layout Plain Layout
Dinamična
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Plain Layout
Čitanje / Pisanje
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none" width="3cm">
\begin_inset Text

\begin_layout Plain Layout
Dinamična
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Plain Layout
Čitanje / Pisanje
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none" width="3cm">
\begin_inset Text

\begin_layout Plain Layout
Dinamična
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Plain Layout
Bez pristupa
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none" width="3cm">
\begin_inset Text

\begin_layout Plain Layout
Dinamična
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Plain Layout
Bez pristupa
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none" width="2cm">
\begin_inset Text

\begin_layout Plain Layout
Programska
\end_layout

\begin_layout Plain Layout
Jezgra
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bez alokacije
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Plain Layout
Čitanje / Pisanje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Statična
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Plain Layout
Čitanje / Pisanje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Statična
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Plain Layout
Čitanje / Pisanje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Statična
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Plain Layout
Čitanje / Pisanje
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
OpenCL
\emph default
 aplikacija pokrenuta na domaćinu kroz 
\emph on
OpenCL
\emph default
 sučelje zauzima lokacije u globalnoj memoriji i stvara memorijske objekte,
 te se brine oko izvođenja memorijskih naredbi.
 Memorijski objekti su zauzeta polja memorije kojima može pristupati domaćin
 i 
\emph on
OpenCL
\emph default
 uređaji.
 Kroz njih aplikacija na domaćinu i programske jezgre koje se izvode na
 
\emph on
OpenCL
\emph default
 uređaju razmjenjuju podatke.
 Memorije na domaćinu i 
\emph on
OpenCL
\emph default
 uređaju su neovisne jedna o drugoj iz razloga što je domaćin izvan 
\emph on
OpenCL
\emph default
 sustava.
 Komunikacija se međutim može ostvariti na dva načina: eksplicitnim kopiranjem
 podataka iz memorije na domaćinu u memoriju na 
\emph on
OpenCL
\emph default
 uređaju i obrnuto ili preslikavanjem (
\shape italic
\emph on
engl.

\emph default
 mapping
\shape default
) njihovih memorijskih područja.
 
\end_layout

\begin_layout Standard
Eksplicitno kopiranje podataka između memorijskih objekata i memorije na
 domaćinu se odvija na zahtjev domaćina, a može biti blokirajuće ili neblokiraju
će, tj.
 izvođenje programa na domaćinu može čekati da kopiranje se završi ili nastaviti
 dalje ne čekajući završetak kopiranja i njegov ishod.
\end_layout

\begin_layout Standard
Kod memorijskog preslikavanja domaćin može 
\emph on
OpenCL
\emph default
 memorijske objekte preslikati u svoj adresni prostor, a naredba za preslikavanj
e može biti blokirajuća i neblokirajuća.
 Kada se memorijski objekt preslika, domaćin može pisati ili čitati po tom
 adresnom prostoru.
 
\end_layout

\begin_layout Standard

\emph on
OpenCL
\emph default
 jamči memorijsku konzistenciju među lokalnom memorijom koja je dostupna
 radnim jedinicama unutar iste radne grupe prilikom sinkronizacijske granice
 (
\shape italic
\emph on
engl.

\emph default
 barrier
\shape default
).
 Isto vrijedi i za globalnu memoriju, ali ne u slučaju radnih jedinica koje
 pripadaju različitim radnim grupama.
\end_layout

\begin_layout Subsubsection
Izvršni model
\end_layout

\begin_layout Standard
Izvođenje 
\emph on
OpenCL
\emph default
 aplikacije se odvija u dva dijela: programske jezgre se izvode na jednom
 ili više računalnih uređaja, a na domaćinu se izvodi tekst programa koji
 upravlja izvođenjem programskih jezgri, točnije brine se za stvaranje konteksta
 (
\shape italic
\emph on
engl.

\emph default
 contex
\shape default
) za izvođenje, programskih slijedova (
\shape italic
\emph on
engl.

\emph default
 programming queues
\shape default
) i stvaranje memorijskih međuspremnika (
\shape italic
\emph on
engl.

\emph default
 memory buffer
\shape default
) za pisanje i čitanje podataka iz memorije uređaja.
\end_layout

\begin_layout Standard
Za pokretanje 
\emph on
OpenCL
\emph default
 aplikacije se moraju definirati veličine dimenzija problema koji se obrađuje,
 jer se prilikom pokretanja programskih jezgri na uređajima stvara indeksni
 prostor koji odgovara tim dimenzijama.
 Dimenzije problema se najlakše mogu ilustrirati na primjeru matrice (Slika
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL-izvršni-model"

\end_inset

.) koja se sastoji od 
\emph on
n
\emph default
 redaka (
\emph on
Gx
\emph default
) i 
\emph on
m
\emph default
 stupaca (
\emph on
Gy
\emph default
).
 Indeksni prostor odgovara dimenzijama matrice, te se za svaki njegov element
 pokreće po jedna radna jedinica, pretpostavimo dretva, koja obrađuje element
 matrice koji se nalazi na dotičnom indeksu.
 Veličina indeksnog prostora ne mora nužno odgovarati dimenzijama matrice,
 moguće je i definirati manji indeksni prostor od dimenzija matrice, pa
 programski unutar svake radne jedinice obraditi više elemenata matrice.
\end_layout

\begin_layout Standard
Možemo definirati jednu, dvije ili tri dimenzije problema, te za svaku dimenziju
 postavljamo veličinu odnosno prirodni broj elemenata u rasponu od 1 do
 N.
 Na temelju tih postavki se stvara indeksni prostor istih dimenzija, a prilikom
 pokretanja svaka radna jedinica (
\shape italic
\emph on
engl.

\emph default
 working-item
\shape default
) obrađuje jedan element iz tog indeksnog prostora, dakle broj radnih jednica
 odgovara veličini indeksnog prostora.
 Svaka radna jedinica pokreće istu programsku jezgru, ali nad različitim
 podacima.
 Taj princip se naziva 
\emph on
SIMD
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
U literaturi vezanoj uz GPU-ove se često nailazi na sličan izraz 
\emph on
SIMT
\emph default
 (engl.
 
\emph on
Single Instruction, Multiple Thread
\emph default
)
\end_layout

\end_inset

, u prijevodu 
\emph on

\begin_inset Quotes eld
\end_inset

jedna instrukcija, višestruki podaci
\begin_inset Quotes erd
\end_inset


\emph default
 .
 Radne jedinice su grupirane u radne grupe (
\shape italic
\emph on
engl.

\emph default
 working-group
\shape default
) koje omogućuju veću zrnatost prilikom izrade algoritma.
\end_layout

\begin_layout Standard
Svaka radna jedinica se može jednoznačno identificirati u indeksnom prostoru
 pomoću globalnih indeksa (
\shape italic
\emph on
engl.

\emph default
 global ID
\shape default
).
 Svaka radna grupa se također može identificirati pomoću indeksa grupa (
\shape italic
\emph on
engl.

\emph default
 work-group ID
\shape default
).
 Radne jedinice se također mogu indentificirati i pomoću lokalnih indeksa
 (
\shape italic
\emph on
engl.

\emph default
 local ID
\shape default
) i grupa kojim pripadaju, odnosno svaka radna jedinica ima i svoj jednoznačni
 lokalni indeks u grupi u kojoj se nalazi (jedna radna jedinica se može
 nalaziti samo u jednog radnoj grupi).
\end_layout

\begin_layout Standard
Pretpostavimo da koristimo dvodimenzionalni prostor za naš problem; prvo
 definiramo veličine dimenzija indeksnog prostora 
\begin_inset Formula $(G_{x},\, G_{y})$
\end_inset

, a zatim veličine dimenzija lokalnog indeksnog prostora 
\begin_inset Formula $(L_{x},\, L_{y})$
\end_inset

, a veličina radne grupe odgovara istim vrijednostima.
 Radne jedinice možemo dohvatiti preko globalnih 
\begin_inset Formula $(g_{x},\, g_{y})$
\end_inset

 i lokalnih 
\begin_inset Formula $(s_{x},\, s_{y})$
\end_inset

 indeksa.
 Veličinu radnih grupa označavamo sa 
\begin_inset Formula $(W_{x},\, W_{y})$
\end_inset

, a njihove indekse sa 
\begin_inset Formula $(w_{x},\, w_{y})$
\end_inset

.
 Sljedeće funkcije opisuju kako možemo dohvatiti željene indekse i veličine:
\end_layout

\begin_layout Standard
\begin_inset VSpace 5mm
\end_inset

Određivanje globalnih indeksa radne jednice preko lokalnih indeksa i indeksa
 grupe:
\end_layout

\begin_layout Standard
\begin_inset Formula $(g_{x},\, g_{y})=(w_{x}\times L_{x}+s_{x},\, w_{y}\times L_{y}+s_{y})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 5mm
\end_inset

Određivanje broja radnih grupa preko globalne i lokalne veličine indeksnog
 prostora:
\end_layout

\begin_layout Standard
\begin_inset Formula $(W_{x},\, W_{y})=(G_{x}/L{}_{x},\, G_{y}/L_{y})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 5mm
\end_inset

Određivanje indeksa radne grupe u kojoj se radna jedinica nalazi, preko
 globalnih indeksa radne jedinice i veličine radne grupe:
\end_layout

\begin_layout Standard
\begin_inset Formula $(w_{x},\, w_{y})=((g_{x}-s_{x})/L_{x},\,(g_{y}-s_{y})/L_{y})$
\end_inset


\begin_inset VSpace 5mm
\end_inset


\end_layout

\begin_layout Standard

\emph on
OpenCL
\emph default
 specifikacija propisuje postojanje funkcija za dohvaćanje globalne i lokalne
 veličine indeksnog prostora po dimenzijama, dohvaćanje globalnog i lokalnog
 indeksa radne jedinice, indeksa radne grupe i broja radnih grupa ovisno
 o dimenziji.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/execution.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL-izvršni-model"

\end_inset

OpenCL
\emph default
 izvršni model
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 5mm
\end_inset


\end_layout

\begin_layout Standard
Navedeni pristup znatno olakšava paralelizaciju algoritama, jer korisnik
 treba definirati veličinu problema po dimenzijama, a sustav se sam do neke
 mjere brine za raspodjelu posla i podataka, te olakšava korisniku kontrolu
 nad paralelizacijom.
 Korisnik može definirati lokalnu veličinu indeksnog prostora odnosno veličinu
 grupa, a ako to ne uradi sustav sam raspodjeljuje indeksni prostor među
 radnim grupama.
 Navedeni model omogućava preslikavanje dva programska modela, podatkovnu
 paralelizaciju i paralelizaciju podjelom na poslove.
\end_layout

\begin_layout Standard
Aplikacija na domaćinu stvara kontekst za izvođenje programskih jezgri na
 
\emph on
OpenCL
\emph default
 uređajima.
 Tekst programske jezgre prevodi 
\emph on
OpenCL
\emph default
 prevodilac (
\shape italic
\emph on
engl.

\emph default
 compiler
\shape default
) koji dolazi sa implementacijom.
 Kontekst sadrži sljedeće resurse:
\end_layout

\begin_layout Itemize
skup OpenCL uređaja koje domaćin koristi,
\end_layout

\begin_layout Itemize
programske jezgre, odnosno OpenCL funkcije koje se izvršavaju na OpenCL
 uređajima,
\end_layout

\begin_layout Itemize
programske objekte, odnosno tekst programa i izvršne datoteke koje sadrže
 programsku jezgru,
\end_layout

\begin_layout Itemize
memorijske objekte koji su vidljivi domaćinu i OpenCL uređajima.
\end_layout

\begin_layout Standard
Kontekstom upravlja domaćin preko funkcija koje definira OpenCL programsko
 sučelje .
 Domaćin potom stvara programski slijed putem kojeg se određuje redoslijed
 i način izvođenja programskih jezgi.
 
\end_layout

\begin_layout Subsubsection
Programski model
\end_layout

\begin_layout Standard
OpenCL sustav podržava dva programska modela, podatkovnu paralelizaciju
 i paralelizaciju po raspodjeli poslova.
 Moguća je i kombinacija dva navedena modela, a primarni je podatkovna paraleliz
acija.
\end_layout

\begin_layout Standard
Prilikom 
\emph on
podatkovne paralelizacije
\emph default
 niz operacija se obavlja na višestrukim elementima memorijskog objekta.
 Ovisno o indeksnom prostoru stvaraju se radne jedinice i raspodjeljuju
 podaci za obradu među njima.
 Preslikavanje može biti jedan podatak na jednu radnu jedinicu, ali OpenCL
 dozvoljava da i više podataka obrađuje jedna radna jedinica.
 Broj radnih jedinica odgovara broju elemenata u indeksnom polju, a korisnik
 može eksplicitno definirati veličinu globalnog i lokalnog polja.
 Ako definira samo veličinu globalnog polja, sustav implicitno određuje
 veličinu lokalnog, podjela ovisi o implementaciji 
\emph on
OpenCL
\emph default
-a.
 Za svaku radnu jedinicu se pokreće paralelno po jedna programska jezgra.
 
\end_layout

\begin_layout Standard
U modelu paralelizacije po poslovima programska jezgra se pokreće neovisno
 o indeksnom prostoru, a pretpostavljamo da jedna radna grupa sadrži samo
 jednu radnu jednicu.
 U ovom slučaju korisnik postiže paralelizam koristeći vektorske tipove
 podataka na 
\emph on
OpenCL
\emph default
 uređaju i stavljajući u red izvršavanja više poslova.
\end_layout

\begin_layout Standard

\emph on
OpenCL
\emph default
 poznaje dvije vrste sinkronizacije, radnih jedinica unutar iste radne grupe
 i stavljanjem poslova u red izvršavanja unutar istog konteksta.
 Sinkronizaciju radnih jedinica postižemo pozivanjem naredbe sinkronizacijske
 granice radne grupe (
\shape italic
\emph on
engl.

\emph default
 working-group barrier
\shape default
).
 Pritom sve radne jedinice unutar radne grupe moraju pozvati naredbu sinkronizac
ije, te nakon toga mogu dalje nastaviti izvršavati naredbe u programskoj
 jezgri.
 Mehanizam sinkronizacije među radnim grupama ne postoji.
\end_layout

\begin_layout Standard
Sinkronizacija poslova u redoslijedu izvršavanja se također postiže pozivanjem
 barijere (
\shape italic
\emph on
engl.

\emph default
 command-queue barrier
\shape default
), a pritom se čeka da svi poslovi u redu izvršavanja završe i pospreme
 rezultate u memorijske objekte tako da postanu vidljivi.
 Također se može čekati na određeni posao u redu izvršavanja.
\end_layout

\begin_layout Subsection
Pregled osnovnih funkcija sustava
\end_layout

\begin_layout Standard
Sustav 
\emph on
OpenCL
\emph default
 omogućuje aplikacijama korištenje domaćina i dostupnih 
\emph on
OpenCL
\emph default
 uređaja kao jedno heterogeno paralelno računalo.
 Sustav se sastoji od sljedećih komponenata:
\end_layout

\begin_layout Itemize

\emph on
OpenCL
\emph default
 platformskog sloja: omogućuje programima na domaćinu otkrivanje 
\emph on
OpenCL
\emph default
 uređaja i njihovih karakteristika, te stvaranje 
\emph on
OpenCL
\emph default
 konteksta;
\end_layout

\begin_layout Itemize

\emph on
OpenCL
\emph default
 izvršnog okruženja (
\shape italic
\emph on
engl.

\emph default
 runtime
\shape default
): omogućuje programu na domaćinu upravljanje kontekstom;
\end_layout

\begin_layout Itemize

\emph on
OpenCL
\emph default
 prevodioca: služi za stvaranje programa koji sadrže programske jezgre koje
 se izvršavaju na 
\emph on
OpenCL
\emph default
 uređajima.
 Tekst programa se piše u 
\emph on
OpenCL C
\emph default
 programskom jeziku.
\end_layout

\begin_layout Standard
U ovom poglavlju će biti opisane samo relevantnije funkcije za osnovno korištenj
e 
\emph on
OpenCL
\emph default
-a, tj.
 one koje su neophodne za kasnije primjere i njihovo objašnjenje.
\end_layout

\begin_layout Subsubsection
OpenCL platformski sloj
\end_layout

\begin_layout Standard

\series bold
Dohvaćanje informacija o platformi
\series default

\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
Za dohvaćanje liste dostupnih platformi koristimo funkciju
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

cl_int clGetPlatformIDs (cl_uint num_entries, 
\end_layout

\begin_layout Plain Layout

                         cl_platform_id *platforms, 
\end_layout

\begin_layout Plain Layout

                         cl_uint *num_platforms) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argument 
\shape italic
num_entries
\shape default
 označava broj platformi koje mogu biti dodane u listu 
\shape italic
platforms
\shape default
.
 Funkcija u listu 
\shape italic
platforms
\shape default
 postavlja identifikatore dostupnih platformi, a kroz 
\shape italic
num_platforms
\shape default
 njihov broj.
 Ako je funkcija uspješno izvedena vraća vrijednost konstante 
\shape italic
CL_SUCCESS
\shape default
.
 Većina funkcija vraća iste vrijednosti ovisno o uspjehu tako da to neće
 biti posebno naznačeno kod opisa daljnih funkcija.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Dalje se kroz funkciju
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clGetPlatformInfo (cl_platform_id platform, 
\end_layout

\begin_layout Plain Layout

                          cl_platform_info param_name, 
\end_layout

\begin_layout Plain Layout

                          size_t param_value_size, 
\end_layout

\begin_layout Plain Layout

                          void *param_value, 
\end_layout

\begin_layout Plain Layout

                          size_t *param_value_size_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
mogu dobiti detaljnije informacije o željenoj platformi tako da se identifikator
 platforme postavi u argument 
\shape italic
platform.

\shape default
 Argument 
\shape italic
param_name
\shape default
 sadrži konstantu koja identificira platformu, 
\shape italic
param_value
\shape default
 je pokazivač na memorijski prostor u kojem je opis platforme, a 
\shape italic
param_value_size
\shape default
 određuje veličinu toga prostora.
 Opis platforme sadrži podatke poput naziva, proizvođača i podržane verzije
 
\emph on
OpenCL
\emph default
-a .
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Dohvaćanje informacija o uređajima
\series default

\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
Za dohvaćanje liste uređaja na željenoj platformi se koristi funkcija
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clGetDeviceIDs (cl_platform_id platform, 
\end_layout

\begin_layout Plain Layout

                       cl_device_type device_type, 
\end_layout

\begin_layout Plain Layout

                       cl_uint num_entries,  
\end_layout

\begin_layout Plain Layout

                       cl_device_id *devices, 
\end_layout

\begin_layout Plain Layout

                       cl_uint *num_devices) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
U argument 
\shape italic
platform
\shape default
 se postavlja identifikator platforme, kroz 
\shape italic
device_type
\shape default
 se može filtrirati lista uređaja ovisno o njihovom tipu (CPU, GPU, ...), a
 preko argumenta 
\shape italic
num_entries
\shape default
 se vraća broj dohvaćenih uređaja, tj.
 onih u koji se nalaze u listi 
\shape italic
devices
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Opširnije informacije o uređaju se dobivaju funkcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clGetDeviceInfo (cl_device_id device, 
\end_layout

\begin_layout Plain Layout

                        cl_device_info param_name, 
\end_layout

\begin_layout Plain Layout

                        size_t param_value_size, 
\end_layout

\begin_layout Plain Layout

                        void *param_value,
\end_layout

\begin_layout Plain Layout

                        size_t *param_value_size_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Identifikator uređaja se određuje argumentom 
\emph on
device
\emph default
, a argument param_name služi za dohvaćanje željene informacije o uređaju.
 Pokazivač 
\shape italic
param_value
\shape default
 određuje memorijsku lokaciju u koju će se zapisati tražane informacije,
 a 
\shape italic
param_value_size
\shape default
 definira njenu veličinu.
 Na taj način se mogu dobiti informacije o uređaju poput vrste, proizvođača,
 broja procesnih jedinica (engl.
 
\emph on
compute units
\emph default
), maksimalnom broju radnih jedinica po dimenziji indeksnog prostora, maksimalno
j veličini radnih grupa i slično.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Funkcije za baratanje kontekstom
\series default

\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
OpenCL kontekst se koristi prilikom izvođenja 
\emph on
OpenCL
\emph default
 aplikacije za upravljanje memorijskim objektima (
\shape italic
\emph on
engl.
 
\emph default
buffers
\shape default
), programskim redovima (
\shape italic
\emph on
engl.
 
\emph default
command-queues
\shape default
) i pokretanjem programskih jezgri (
\shape italic
\emph on
engl.
 
\emph default
kernels
\shape default
) na uređajima (
\shape italic
\emph on
engl.
 
\emph default
devices
\shape default
).
\end_layout

\begin_layout Standard
Za stvaranje 
\emph on
OpenCL
\emph default
 konteksta koristimo funkciju 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_context clCreateContext (const cl_context_properties *properties, 
\end_layout

\begin_layout Plain Layout

                            cl_uint num_devices, 
\end_layout

\begin_layout Plain Layout

                            const cl_device_id *devices, 
\end_layout

\begin_layout Plain Layout

                            void (*pfn_notify)(const char *errinfo, 
\end_layout

\begin_layout Plain Layout

                                          const void *private_info, 
\end_layout

\begin_layout Plain Layout

                                          size_t cb, 
\end_layout

\begin_layout Plain Layout

                                          void *user_data), 
\end_layout

\begin_layout Plain Layout

                            void *user_data, 
\end_layout

\begin_layout Plain Layout

                            cl_int *errcode_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argument 
\shape italic
proporties
\shape default
 služi za postavljanje željenih opcija konektstu, može biti 
\shape italic
NULL
\shape default
 i onda ovisi o implementaciji.
 Uređaje koje želimo da kontekst koristi dodajemo tako da njihove identifikatore
 stavimo u listu 
\shape italic
devices
\shape default
, a njihov broj stavimo u argument 
\shape italic
num_devices
\shape default
.
 Argumenti 
\shape italic
pfn_notify
\shape default
 i 
\shape italic
user_data
\shape default
 služe za prijavljivanje eventualnih grešaka i događaja koji se mogu dogoditi
 u kontekstu, može se postaviti i samo 
\shape italic
NULL
\shape default
 pa se prijava takvih događaja zanemaruje.
 U 
\shape italic
errcode_ret
\shape default
 se postavi kod eventualne greške ili uspjeha pri stvaranju konteksta, a
 funkcija nazad vraća kontekst koji je stvorila.
\end_layout

\begin_layout Standard
Također je dostupna funkcija 
\shape italic
clCreateContextFromType
\shape default
 koja je jednostavnija verzija prethodne.
 Kod nje su argumenti 
\shape italic
num_devices
\shape default
 i 
\shape italic
devices
\shape default
 zamijenjeni sa 
\shape italic
device_type
\shape default
 kojom se definira tip uređaja koji želimo koristiti, odnosno CPU i/ili
 GPU (
\shape italic
CL_DEVICE_TYPE_{CPU|GPU|ACCELERATOR|DEFAULT|ALL}
\shape default
).
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Informacije o stvorenom kontekstu se kasnije mogu dobiti funkcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clGetContextInfo (cl_context context, 
\end_layout

\begin_layout Plain Layout

                         cl_context_info param_name, 
\end_layout

\begin_layout Plain Layout

                         size_t param_value_size, 
\end_layout

\begin_layout Plain Layout

                         void *param_value, 
\end_layout

\begin_layout Plain Layout

                         size_t *param_value_size_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
U argument 
\shape italic
context
\shape default
 se postavlja željeni kontekst, a u 
\shape italic
param_name
\shape default
 se postavlja konstanta naziva parametra koji želimo dohvatiti.
 Rezultat se zapisuje na memorijsku lokaciju na koju pokazivač 
\shape italic
param_value
\shape default
 pokazuje, a 
\shape italic
param_value_size
\shape default
 definira njegovu veličinu.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Subsubsection
OpenCL izvršno okruženje
\end_layout

\begin_layout Standard

\series bold
Funkcije vezane uz programski slijed
\series default

\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
Nakon što se stvori kontekst i objekti u njemu (memorijski, jezgre, ...), njima
 se upravlja preko programskog slijeda (
\shape italic
\emph on
engl.

\emph default
 command-queue
\shape default
).
 U programski slijed se mogu stavljati naredbe koje će se redom izvoditi,
 a također je moguće definirati više programskih slijedova u koje će se
 stavljati naredbe i izvršavati neovisno jedna o drugoj.
 Prilikom korištenja više programskih slijedova se ne smiju djeliti isti
 objekti, točnije podaci u memoriji, među slijedovima zbog nedostatka sinkroniza
cije.
\end_layout

\begin_layout Standard
Programske slijedove stvaramo funkcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_command_queue clCreateCommandQueue (cl_context context, 
\end_layout

\begin_layout Plain Layout

                                       cl_device_id device, 
\end_layout

\begin_layout Plain Layout

                                       cl_command_queue_properties properties,
 
\end_layout

\begin_layout Plain Layout

                                       cl_int *errcode_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argumentom 
\shape italic
context
\shape default
 se određuje kontekst za koji se želi stvoriti programski slijed, a lista
 uređaja se određuje argumentom 
\shape italic
device
\shape default
, dok uređaji moraju biti povezani sa konekstom koji se koristi.
 Dodatne opcije se mogu definirati kroz argument 
\shape italic
properties
\shape default
, a ishod funkcije se stavlja u 
\shape italic
errcode_ret
\shape default
.
 U slučaju uspjeha funkcija vraća upravo stvoreni programski slijed.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Dodatne informacije o programskom slijedu se dobivaju kroz funkciju
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clGetCommandQueueInfo (cl_command_queue command_queue, 
\end_layout

\begin_layout Plain Layout

                              cl_command_queue_info param_name, 
\end_layout

\begin_layout Plain Layout

                              size_t param_value_size, 
\end_layout

\begin_layout Plain Layout

                              void *param_value, 
\end_layout

\begin_layout Plain Layout

                              size_t *param_value_size_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argumentom 
\shape italic
command_queue
\shape default
 se određuje željeni programski slijed preko njegovog indentifikatora, 
\shape italic
param_name
\shape default
 označava informaciju koju želimo dohvatiti, pokazivač 
\shape italic
param_value
\shape default
 pokazuje na memorijsku lokaciju na koju će biti upisan rezultat, a 
\shape italic
param_value_size
\shape default
 veličinu memorijske lokacije.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Korištenje memorijskih objekata
\series default

\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
Memorijski objekti mogu pripadati tipovima objekata međuspremnika (engl.
 
\emph on
buffer object
\emph default
) ili slika (engl.
 
\emph on
image object
\emph default
).
 Objekti slika neće biti obrađeni ovdje jer nisu bitni za kasnije primjere.
 Ukratko opisano, služe za stvaranje dvodimenzionalnih ili trodimenzionalnih
 slika, tekstura i međuspremnika slika za prikaz na zaslonu.
\end_layout

\begin_layout Standard
Objekti tipa međuspremnika, koji sa nadalje koriste, su jednodimenzionalni
 nizovi u koje se stavljaju podaci, poput cijelih brojeva i onih sa pomičnim
 zarezom, vektora podataka i struktura podataka definiranih od strane korisnika.
 Služe za prijenos podataka između aplikacije na domaćinu i programskih
 jezgri koje se izvode na 
\emph on
OpenCL
\emph default
 uređajima.
 Podaci u objektima međuspremnika moraju biti podatkovnog tipa koji je čitljiv
 od stane aplikacije i programskih jezgri.
\end_layout

\begin_layout Standard
Za stvaranje objekta međuspremnika koristi se funkcija
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_mem clCreateBuffer (cl_context context, 
\end_layout

\begin_layout Plain Layout

                       cl_mem_flags flags, 
\end_layout

\begin_layout Plain Layout

                       size_t size,
\end_layout

\begin_layout Plain Layout

                       void *host_ptr, 
\end_layout

\begin_layout Plain Layout

                       cl_int *errcode_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pritom argument 
\shape italic
context
\shape default
 određuje kontekst u kojem se stvara objekt.
 Atribut 
\shape italic
flags
\shape default
 je niz bitova kojim se postavljaju određeni atributi za kreiranje objekta
 međuspremnika, poput prava pristupa i načina zauzimanja memorije.
 Argumentom 
\shape italic
size
\shape default
 se određuje veličina međuspremnika u oktetima, 
\shape italic
host_ptr
\shape default
 je pokazivač na memorijsku lokaciju na kojoj već mogu biti podaci namijenjeni
 međuspremniku.
 U 
\shape italic
errcode_ret
\shape default
 će se postaviti eventualna greška nastala prilikom stvaranja međuspremnika.
 Funkcija u slučaju uspješnog izvođenja vraća objekt međuspremnika.
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
zastavica
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CL_MEM_READ_WRITE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jezgra može čitati i pisati u mem.
 objekt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CL_MEM_WRITE_ONLY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jezgra može samo pisati u objekt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CL_MEM_READ_ONLY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jezgra može samo čitati iz objekta
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CL_MEM_USE_HOST_PTR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Koristi se memorija domaćina za mem.
 objekt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CL_MEM_ALLOC_HOST_PTR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OpenCL implementacija zauzima memoriju za objekt dostupnu domaćinu 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CL_MEM_COPY_HOST_PTR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OpenCL implementacija zauzima memoriju i u nju kopira sadržaj sa pokazivača
 
\shape italic
host_ptr
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Sljedeće funkcije su relativno slične, a služe za čitanje objekta međuspremnika
 i postavljanje tih podataka u memoriju domaćina, te upisivanje podataka
 u objekt međuspremnika iz memorije domaćina.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clEnqueueReadBuffer (cl_command_queue command_queue, 
\end_layout

\begin_layout Plain Layout

                            cl_mem buffer, 
\end_layout

\begin_layout Plain Layout

                            cl_bool blocking_read, 
\end_layout

\begin_layout Plain Layout

                            size_t offset, 
\end_layout

\begin_layout Plain Layout

                            size_t cb, 
\end_layout

\begin_layout Plain Layout

                            void *ptr, 
\end_layout

\begin_layout Plain Layout

                            cl_uint num_events_in_wait_list, 
\end_layout

\begin_layout Plain Layout

                            const cl_event *event_wait_list, 
\end_layout

\begin_layout Plain Layout

                            cl_event *event) 
\end_layout

\end_inset


\begin_inset VSpace 3mm
\end_inset


\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clEnqueueWriteBuffer (cl_command_queue command_queue, 
\end_layout

\begin_layout Plain Layout

                             cl_mem buffer, 
\end_layout

\begin_layout Plain Layout

                             cl_bool blocking_write, 
\end_layout

\begin_layout Plain Layout

                             size_t offset, 
\end_layout

\begin_layout Plain Layout

                             size_t cb, 
\end_layout

\begin_layout Plain Layout

                             const void *ptr, 
\end_layout

\begin_layout Plain Layout

                             cl_uint num_events_in_wait_list, 
\end_layout

\begin_layout Plain Layout

                             const cl_event *event_wait_list, 
\end_layout

\begin_layout Plain Layout

                             cl_event *event) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Željni programski slijed u kojem će se operacija izvesti se određuje argumentom
 
\shape italic
command_queue
\shape default
, a objekt međuspremnika argumentom 
\shape italic
buffer
\shape default
.
 Argumentima 
\shape italic
blocking_write
\shape default
 i 
\shape italic
blocking_read
\shape default
 se određuje hoće li ponašanje funkcije biti blokirajuće ili neblokirajuće,
 odnosno hoće li povratak iz funkcije uslijediti tek nakon izvršene operacije
 ili ne.
 Argument 
\shape italic
offset
\shape default
 određuje pomak od memorijske lokacije međuspremnika, 
\shape italic
cb
\shape default
 veličinu podataka koji se čitaju ili upisuju, a pokazivač 
\shape italic
ptr
\shape default
 pokazuje na memoriju domaćina iz koje se čita ili u koju se upisuje.
 Argumentima 
\shape italic
num_events_in_wait
\shape default
 list i 
\shape italic
event_wait_list
\shape default
 se mogu odrediti događaji na koje funkcija mora pričekati da se izvrše,
 također mogu biti postavljeni na 
\shape italic
NULL
\shape default
.
 Kroz argument 
\shape italic
event
\shape default
 funkcija vraća objekt događaja uz pomoć kojeg se kasnije može provjeriti
 je li naredba izvršena ili ne.
\end_layout

\begin_layout Standard
Funkcijom 
\shape italic
clEnqueueCopyBuffer
\shape default
 se može sadržaj jednog objekta međuspremnika kopirati u drugi, a funkcijom
 
\shape italic
clReleaseMemObject
\shape default
 se smanjuje brojač memorijskih objekata, te navedeni objekt briše nakon
 što se izvedu naredbe u programskom slijedu kojem pripada.
\end_layout

\begin_layout Standard
Memorijski objekti se također mogu i preslikavati, tj.
 dio međuspremnika se može preslikati u memorijski prostor domaćina.
 Za to se koriste funkcije 
\shape italic
clEnqueueMapBuffer
\shape default
 i 
\shape italic
clEnqueueUnmapMemObject
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Stvaranje programskih objekta
\series default

\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
OpenCL program je skupina jedne ili više programskih jezgri.
 Deklariramo ih tako da u 
\emph on
OpenCL
\emph default
 programskom kodu ispred funkcije postavimo atribut 
\shape italic
__kernel
\shape default
.
 Programski objekt sadrži sljedeće informacije:
\end_layout

\begin_layout Itemize
informaciju kojem kontekstu pripada,
\end_layout

\begin_layout Itemize
izvorni tekst programa programa ili njegov prevedeni binarni zapis,
\end_layout

\begin_layout Itemize
izvršnu datoteku programa, listu uređaja za koje je prevedena, te opcije
 koje su pritom korištene,
\end_layout

\begin_layout Itemize
broj programskih jezgri koje se nalaze u njemu.
\end_layout

\begin_layout Standard
Programski objekt se stvara fukcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_program clCreateProgramWithSource (cl_context context, 
\end_layout

\begin_layout Plain Layout

                                      cl_uint count, 
\end_layout

\begin_layout Plain Layout

                                      const char **strings, 
\end_layout

\begin_layout Plain Layout

                                      const size_t *lengths, 
\end_layout

\begin_layout Plain Layout

                                      cl_int *errcode_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argumentom 
\shape italic
context
\shape default
 se određuje kontekst u kojem se stvara objekt, lista pokazivača 
\shape italic
strings
\shape default
, duljine 
\shape italic
count
\shape default
, pokazuje na linije izvornog programskog koda, a njihove duljine su postavljene
 u listu 
\shape italic
lengths
\shape default
.
 U 
\shape italic
errcode_ret
\shape default
 se postaviti eventualna greška nastala prilikom stvaranja programa.
 Funkcija u slučaju uspješnog izvođenja vraća programski objekt.
\end_layout

\begin_layout Standard
Osim stvaranja programskog objekta iz izvornog programskog koda, on se može
 stvoriti i iz binarnog zapisa uz pomoć funkcije 
\shape italic
clCreateProgramWithBinary
\shape default
.
\end_layout

\begin_layout Standard
Funkcijom 
\shape italic
clReleaseProgram
\shape default
 se smanjuje brojač programskih objekata, te navedeni objekt uništava nakon
 što se unište sve programske jezgre povezane sa njim.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Stvaranje izvršnih datoteka programa
\end_layout

\begin_layout Standard
\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
Funkcija
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clBuildProgram (cl_program program, 
\end_layout

\begin_layout Plain Layout

                       cl_uint num_devices, 
\end_layout

\begin_layout Plain Layout

                       const cl_device_id *device_list, 
\end_layout

\begin_layout Plain Layout

                       const char *options, 
\end_layout

\begin_layout Plain Layout

                       void (*pfn_notify)(cl_program, void *user_data),
 
\end_layout

\begin_layout Plain Layout

                       void *user_data) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
se koristi za prevođenje i povezivanje izvršne datoteke programa iz izvornog
 teksta programa.
 Stvara se izvršna datoteka za sve 
\emph on
OpenCL
\emph default
 uređaje definirane u kontekstu kojem program pripada.
 Navedenu funkciju je obavezno pozvati nakon stvaranja programskog objekta
 sa nekom od prethodne dvije funkcije.
\end_layout

\begin_layout Standard
Argumentom 
\shape italic
program
\shape default
 definira se prije stvoreni programski objekt, listom 
\shape italic
device_list
\shape default
, duljine 
\shape italic
num_devices
\shape default
, mogu se specificirati uređaji za koje je izvršna datoteka namijenjena,
 u slučaju 
\shape italic
NULL
\shape default
 vrijednosti se uređaji određuju po povezanosti sa programskim objektom.
 Argumentom 
\shape italic
options
\shape default
 se mogu postaviti neki dodatni parametri prevodiocu poput optimizacijskih
 tehnika, razine upozorenja i slično.
 Argumenti 
\shape italic
pfn_notify
\shape default
 i 
\shape italic
user_data
\shape default
 se mogu koristiti za pozivanje željene funkcije prilikom završetka prevođenja.
 Ovisno o ishodu prevođenja, funkcija vraća vrijednost koja može biti 
\shape italic
CL_SUCCESS
\shape default
 u slučaju uspjeha ili neka druga konstanta koja opisuje tip greške.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Dodatne informacije o programskom objektu se mogu dobiti funkcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clGetProgramInfo (cl_program program, 
\end_layout

\begin_layout Plain Layout

                         cl_program_info param_name, 
\end_layout

\begin_layout Plain Layout

                         size_t param_value_size, 
\end_layout

\begin_layout Plain Layout

                         void *param_value, 
\end_layout

\begin_layout Plain Layout

                         size_t *param_value_size_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argument 
\shape italic
program
\shape default
 specificira programski objekt, 
\shape italic
param_name
\shape default
 naziv informacije koja se želi dohvatiti, a postavlja je na memorijsku
 lokaciju na koju pokazuje 
\shape italic
param_value
\shape default
, njena veličina je definirana argumentom 
\shape italic
param_value_size
\shape default
.
 Navedenom funkcijom se mogu saznati vrijednosti poput konteksta kojem objekt
 pripada, 
\emph on
OpenCL
\emph default
 uređaji sa kojima je povezan, te tekstualni i binarni zapis programa.
\end_layout

\begin_layout Standard
Status stvaranja programskog objekta se može saznati funkcijom 
\shape italic
clGetProgramBuildInfo
\shape default
, ovisno o 
\emph on
OpenCL
\emph default
 uređaju.
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Stvaranje objekata programskih jezgri
\series default

\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
Objekt programske jezgre stvaramo funkcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_kernel clCreateKernel (cl_program program, 
\end_layout

\begin_layout Plain Layout

                          const char *kernel_name, 
\end_layout

\begin_layout Plain Layout

                          cl_int *errcode_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
gdje je argument 
\shape italic
program
\shape default
 programski objekt za izvršnom datotekom, 
\shape italic
kernel_name
\shape default
 naziv funkcije u izvornom kodu programske jezgre, a 
\shape italic
errcode_ret
\shape default
 se koristi za prijavu identifikatora eventualnih grešaka.
 Funkcija u slučaju uspjeha vraća objekt programske jezgre.
\end_layout

\begin_layout Standard
Umjesto da stvaramo jedan po jedan objekt programske jezgre, mogu se stvoriti
 i svi odjednom u pojedinom programu uz pomoć funkcije 
\shape italic
clGetProgramBuildInfo
\shape default
.
\end_layout

\begin_layout Standard
Programske jezgre se stvaraju nakon što se stvori program sa odgovarajućim
 izvornim ili binarnim zapisom 
\emph on
OpenCL
\emph default
 programskog koda.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Izrazito je bitna funkcija za postavljanje argumenata programskoj jezgri,
 kako bi se jezgra kasnije mogla izvesti.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clSetKernelArg (cl_kernel kernel, 
\end_layout

\begin_layout Plain Layout

                       cl_uint arg_index, 
\end_layout

\begin_layout Plain Layout

                       size_t arg_size, 
\end_layout

\begin_layout Plain Layout

                       const void *arg_value) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argumentom 
\shape italic
kernel
\shape default
 se postavlja objekt programske jezgre, 
\shape italic
arg_index
\shape default
 služi za određivanje rednog broja argumenta u funkciji programske jezgre
 koji postavljamo, počevši od 0.
 Pokazivač 
\shape italic
arg_value
\shape default
 pokazuje na vrijednost koja se želi proslijediti kao argument, najčešće
 je to memorijski objekt (međuspremnik) prije stvoren u istom kontekstu
 kao i program.
 U slučaju da argument označava lokalnu OpenCL memoriju (
\shape italic
__local
\shape default
) se umjesto pokazivača stavlja 
\shape italic
NULL
\shape default
.
 Argument 
\shape italic
arg_size
\shape default
 označava veličinu argumenta odnosno međuspremnika koji želimo proslijediti
 funkciji, u slučaju da se radi o lokalnoj memoriji gdje je vrijednost 
\shape italic
NULL
\shape default
, onda se preko 
\shape italic
arg_size
\shape default
 označava veličina lokalne memorije koja će se zauzeti.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Dodatne informacije o objektu programske jezgre, poput konteksta i broja
 parametara, se mogu dobiti funkcijom 
\shape italic
clGetKernelInfo
\shape default
.
 Također je od koristi i funkcija
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clGetKernelWorkGroupInfo (cl_kernel kernel, 
\end_layout

\begin_layout Plain Layout

                                 cl_device_id device, 
\end_layout

\begin_layout Plain Layout

                                 cl_kernel_work_group_info param_name, 
\end_layout

\begin_layout Plain Layout

                                 size_t param_value_size, 
\end_layout

\begin_layout Plain Layout

                                 void *param_value, 
\end_layout

\begin_layout Plain Layout

                                 size_t *param_value_size_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
kojom možemo dobiti informacije o objektu jezgre ovisno o 
\emph on
OpenCL
\emph default
 uređaju.
 Argumentom 
\shape italic
kernel
\shape default
 se definira objekt jezgre, za uređaj postavimo 
\shape italic
device
\shape default
, a naziv parametra koji se želi dohvatiti kroz 
\shape italic
param_name
\shape default
.
 Rezultat se upisuje na memorijsku lokaciju na koju pokazuje 
\shape italic
param_value
\shape default
, a veličine je 
\shape italic
param_value_size
\shape default
.
 Parametrom 
\shape italic
CL_KERNEL_WORK_GROUP_SIZE
\shape default
 se dohvaća maksimalana veličina radnih-grupa koje se mogu koristiti u dotičnoj
 jezgri na uređaju, a 
\shape italic
CL_KERNEL_LOCAL_MEM_SIZE
\shape default
 količina lokalne memorij koju koristi jezgra.
 
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Izvođenje programskih jezgri
\series default

\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
Za stavljanje naredbe za izvršavanje programske jezgre u programski slijed
 koristi se funkcija
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clEnqueueNDRangeKernel (cl_command_queue command_queue, 
\end_layout

\begin_layout Plain Layout

                               cl_kernel kernel, 
\end_layout

\begin_layout Plain Layout

                               cl_uint work_dim, 
\end_layout

\begin_layout Plain Layout

                               const size_t *global_work_offset, 
\end_layout

\begin_layout Plain Layout

                               const size_t *global_work_size, 
\end_layout

\begin_layout Plain Layout

                               const size_t *local_work_size, 
\end_layout

\begin_layout Plain Layout

                               cl_uint num_events_in_wait_list, 
\end_layout

\begin_layout Plain Layout

                               const cl_event *event_wait_list, 
\end_layout

\begin_layout Plain Layout

                               cl_event *event) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argumentom 
\shape italic
commad_queue
\shape default
 se određuje u kojem se programskom slijedu treba izvršiti programska jezgra,
 
\emph on
OpenCL
\emph default
 uređaj je određen programskim slijedom.
 Argument 
\shape italic
kernel
\shape default
 je objekt programske jezgre koji želimo izvesti.
 Broj dimenzija indeksnog prostora se postavlja argumentom 
\shape italic
work_dim
\shape default
, čija vrijednost mora biti između 1 i 3.
 
\shape italic
Global_work_offset
\shape default
 se mora u trenutnoj verziji 
\emph on
OpenCL
\emph default
-a postaviti na 
\emph on
NULL
\emph default
.
 Argumentima 
\shape italic
global_work_size
\shape default
 i 
\shape italic
local_work_size
\shape default
 se definira broj globalnih odnosno lokalnih radnih jedinica po dimenzijama,
 a svakom argumentu se pridružuje niz brojeva duljine jednake broju dimenzija.
 
\shape italic
Local_work_size
\shape default
 se može postaviti i na 
\emph on
NULL
\emph default
, u kojem slučaju veličina lokalne radne grupe ovisi o 
\emph on
OpenCL
\emph default
 implementaciji.
 Na taj način se prilikom izvođenja specificira veličina indeksnog prostora
 i broj globalnih i lokalnih radnih jedinica, tj.
 paralelizira se problem koji rješavamo.
 Argumentima 
\shape italic
num_events_in_wait_list
\shape default
 i 
\shape italic
event_wait_list
\shape default
 se mogu odrediti koji se događaji moraju završiti prije nego se navedena
 jezgra počne izvoditi.
 Kroz 
\shape italic
event
\shape default
 se vraća objekt događaja koji identificira izvođenje programske jezgre,
 što se može koristiti prilikom redoslijeda izvođenja događaja, tj.
 paralelizacije po poslovima.
\end_layout

\begin_layout Standard
Programska jezgra se može izvesti i funkcijom 
\shape italic
clEnqueueTask
\shape default
, pri čemu je izvodi samo jedna radna jedinica, tj.
 ishod je isti kao da smo definirali samo jednu dimenziju veličine jedan.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Objekti događaja
\series default

\begin_inset VSpace 2mm
\end_inset


\end_layout

\begin_layout Standard
Objekti događaja se mogu koristiti za praćenje izvođenja programskih jezgri,
 operacija pisanja i čitanja memorijskih objekata.
 Na taj način se može raspoređivati izvođenje poslova.
 Funkcijom
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clWaitForEvents (cl_uint num_events, 
\end_layout

\begin_layout Plain Layout

                        const cl_event *event_list)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
domaćin može pričekati da se završe događaji u listi 
\shape italic
event_list
\shape default
, duljine 
\shape italic
num_events
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Dodatne informacije o stanju objekta događaja se dohvaćaju funkcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clGetEventInfo (cl_event event, 
\end_layout

\begin_layout Plain Layout

                       cl_event_info param_name, 
\end_layout

\begin_layout Plain Layout

                       size_t param_value_size, 
\end_layout

\begin_layout Plain Layout

                       void *param_value, 
\end_layout

\begin_layout Plain Layout

                       size_t *param_value_size_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argumentom 
\shape italic
event
\shape default
 se odredi objekt događaja, 
\shape italic
param_name
\shape default
 naziv željene informacije, npr.
 
\shape italic
EXECUTION_STATUS
\shape default
 za praćenje izvršavanja.
 Rezultat se upisuje na mjesto pokazivača 
\shape italic
param_value
\shape default
, veličine 
\shape italic
param_value_size
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Čekanje na izvršenje jednog ili više događaja se postiže funkcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clEnqueueWaitForEvents (cl_command_queue command_queue, 
\end_layout

\begin_layout Plain Layout

                               cl_uint num_events,
\end_layout

\begin_layout Plain Layout

                               const cl_event *event_list) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Definira se željeni programski slijed argumentom 
\shape italic
command_queue
\shape default
, lista događaja koji se žele pričekati se stavlja u listu 
\shape italic
event_list
\shape default
, duljine 
\shape italic
num_events
\shape default
.
 Objekti događaja moraju biti dobiveni iz neke od prethodnih funkcija, poput
 
\shape italic
clEnqueueNDRangeKernel
\shape default
 i 
\shape italic
clEnqueue{Read|Write}Buffer
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Čekanje na kraj izvršavanja svih poslova u programskom slijedu se postiže
 funkcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clEnqueueBarrier (cl_command_queue command_queue)
\end_layout

\end_inset


\begin_inset VSpace 3mm
\end_inset


\end_layout

\begin_layout Standard
Vrijeme duljine izvođenja programskih jezgri odnosno događaja se može pratiti
 funkcijom
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

cl_int clGetEventProfilingInfo (cl_event event, 
\end_layout

\begin_layout Plain Layout

                                cl_profiling_info param_name, 
\end_layout

\begin_layout Plain Layout

                                size_t param_value_size, 
\end_layout

\begin_layout Plain Layout

                                void *param_value, 
\end_layout

\begin_layout Plain Layout

                                size_t *param_value_size_ret) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
U argument 
\shape italic
event
\shape default
 se postavi objekt željenog događaja, sa 
\shape italic
param_name
\shape default
 se definira vrijednost koja se želi dohvatiti, npr.
 
\shape italic
CL_PROFILING_COMMAND_START
\shape default
 i 
\shape italic
CL_PROFILING_COMMAND_END
\shape default
, a povratna vrijednost se upisuje u memoriju pokazivača 
\shape italic
param_value
\shape default
, veličine 
\shape italic
param_value_size
\shape default
.
\end_layout

\begin_layout Subsubsection
OpenCL C programski jezik i prevodilac
\end_layout

\begin_layout Standard

\emph on
OpenCL C
\emph default
 je proširenje ISO C99 programskog jezika koji se najčešće naziva samo 
\shape italic

\begin_inset Quotes eld
\end_inset

C
\begin_inset Quotes erd
\end_inset


\shape default
.
 Točnije osim što je jezik proširen, tako su i neke njegove funkcionalnosti
 izbačene, tj.
 nisu dozvoljene, najčešće zbog načina izvođenja OpenCL programskih jezgri.
 To su pokazivači na funkcije, mogućnost rekurzije, varijabilne duljine
 nizova, te neke druge specifičnosti.
 S druge strane proširenja uključuju rad sa radnim jedinicama i grupama,
 vektorske tipove podataka, mogućnost sinkronizacije, te općenito neka proširenj
a za paralelizam, baratanje sa slikama, povezivanje sa OpenGL sustavom i
 tako dalje.
\end_layout

\begin_layout Standard
Na raspolaganju su skalarni tipovi podataka koje uobičajeno posjeduju i
 drugi programski jezici, poput znakova (
\shape italic
char
\shape default
), cijelih brojeva (
\shape italic
short
\shape default
, 
\shape italic
ushort
\shape default
, 
\shape italic
int
\shape default
, 
\shape italic
uint
\shape default
, 
\shape italic
long
\shape default
, 
\shape italic
ulong
\shape default
) i brojeva sa pomičnim zarezom (
\shape italic
half
\shape default
, 
\shape italic
float
\shape default
), zatim vektorski tipovi podataka mogučih duljina 2, 4, 8, i 16 (
\shape italic
char2
\shape default
, 
\shape italic
short4
\shape default
, 
\shape italic
int8
\shape default
, 
\shape italic
float16
\shape default
, ...) i neke predefinirane konstante.
 Naravno cijeli skup matematičkih i logičkih operatora nad tipovima podataka
 je na raspolaganju, funkcije za konverziju među različitim tipovima podataka,
 uobičajene matematičke funkcije poput trigonometrijskih, zatim neke specifičnij
e funkcije za baratanje geometrijom, rad sa slikama i povezivanje sa 
\emph on
OpenGL
\emph default
-om.
\end_layout

\begin_layout Standard
Bitno je posebno izdvojiti atribute (kvalifikatore) koji se mogu pridružiti
 varijablama, a definiraju adresni prostor kojem varijabla pripada.
 
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
OpenCL C
\emph default
: memorijski atributi varijabli
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="12cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
kvalifikator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__global
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
referencira se na memorijske objekte poput međuspremnika u globalnom memorijskom
 prostoru
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__local
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
opisuje varijable u lokalnom memorijskom prostoru, mogu im pristupati radne
 jedinice unutar iste radne grupe
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__constant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
definira varijable u globalnoj memoriji kojima mogu pristupati sve radne
 jedinice, ali samo sa pravom čitanja
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__private
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sve varijeable unutar funkcija programske jezgre ili koje su kao argumenti
 prosljeđene pripadaju privatnom adresnom prostoru
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Također su neophodne funkcije za baratanje radnim jedinicama.
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
OpenCL C
\emph default
: funkcije za indeksni prostor 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="11cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
funkcija
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_work_dim()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vraća broj dimenzija adresnog prostora, do 1 do 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_global_size(
\shape italic
D
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vraća broj globalnih radnih jedinica za dimenziju 
\shape italic
D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_global_id(
\shape italic
D
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vraća jedinstven identifikator radne jedinice za dimenziju 
\shape italic
D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_local_size(
\shape italic
D
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vraća broj lokalnih radnih jedinica za dimenziju 
\shape italic
D
\shape default
, 
\end_layout

\begin_layout Plain Layout
tj.
 koliko ih se nalazi u jednoj radnoj grupi po dimenziji 
\shape italic
D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_local_id(
\shape italic
D
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vraća jedinstven identifikator radne jedinice u radnoj grupi za dimenziju
 
\shape italic
D
\shape default
, radne jedinice u različitim radnim grupama mogu imati iste identifikatore
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_num_groups(
\shape italic
D
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vraća broj radnih grupa po dimenziji 
\shape italic
D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_group_id(
\shape italic
D
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vraća jedinstveni identifikator radne grupe za dimenziju 
\shape italic
D
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Uz pomoć navedenih funkcija paralelizira se obavljanje posla u programskim
 jezgrama, odnosno ovisno o identifikatoru radnih jedinica se mogu specificirati
 podaci koje će ona obrađivati.
\end_layout

\begin_layout Standard
Za sinkronizaciju su dostupne funkcije u tablici 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:OpenCL-C:-sinkronizacijske"

\end_inset

 .
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:OpenCL-C:-sinkronizacijske"

\end_inset

OpenCL C: sinkronizacijske funkcije
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
funkcija
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
barrier(
\shape italic
flags
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sve radne jedinice u istoj radnoj grupi čekaju
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mem_fence(
\shape italic
flags
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sva čitanja i pisanja po memoriji se čekaju
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
read_mem_fence(
\shape italic
flags
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
čeka se samo završetak čitanja iz memorije
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
write_mem_fence(
\shape italic
flags
\shape default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
čeka se samo završetak pisanja u memoriju
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Svaka funkcija za argument prima konstante (zastavice) 
\shape italic
CLK_LOCAL_MEM_FENCE
\shape default
 i 
\shape italic
CLK_GLOBAL_MEM_FENCE
\shape default
, te njihovu kombinaciju, njima se određuje radili li se o globalnoj i/ili
 lokalnoj memoriji.
\end_layout

\begin_layout Standard

\emph on
OpenCL C
\emph default
 je osmišljen s ciljem olakšavanja paralelizacije po podacima i poslovima,
 a zadržan je na niskoj razini kako bi bio efikasan što se tiče performansi,
 jer je to područje kojem je OpenCL namijenjen.
 Prevodi ga OpenCL prevodilac koji dolazi uključen u OpenCL implementaciji.
 
\end_layout

\begin_layout Subsection
Ilustracija OpenCL-a na primjeru
\end_layout

\begin_layout Standard
Sljedeći primjer ukratko ilustrira općenitu 
\emph on
OpenCL
\emph default
 aplikaciju koja sadrži tekst programa domaćina i programske jezgre.
 Aplikacija nema neku posebnu namjenu, već samo zbraja elemente dva ulazna
 niza i rezultat vraća u izlaznom nizu.
 Zbrajanje se u ovom slučaju odvija na GPU uređaju.
 Ulazni nizovi se na domaćinu alociraju i popunjavaju slučajnim podacima
 , zatim se prosljeđuju uređaju koji obavlja zbrajanje elemenata, a rezultate
 sa uređaja domaćin kopira u svoju memoriju te ih ispisuje.
\end_layout

\begin_layout Standard
Za ovu zadaću je potrebno stvoriti kontekst, programski slijed, memorijske
 objekte međuspremnika i programa, prevesti programsku jezgru za željene
 
\emph on
OpenCL
\emph default
 uređaje, postaviti argumente i izvesti programsku jezgru, osloboditi zauzetu
 memoriju i uništiti stvorene objekte.
 Ovaj primjer prikazuje sve neophodne radnje za stvaranje 
\emph on
OpenCL
\emph default
 aplikacije.
 Svaka naredba u programskom kodu je dokumentirana, a zbog jednostavnosti
 i čitljivosti nema nikakve provjere uspješnosti izvođenja funkcija i njihovih
 rezultata, poput neuspjelog stvaranja konteksta i programskog slijeda,
 memorijskih objekata, alociranja memorije i slično.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language={C++},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> 
\end_layout

\begin_layout Plain Layout

#include <stdlib.h> 
\end_layout

\begin_layout Plain Layout

#include <time.h> 
\end_layout

\begin_layout Plain Layout

#include <CL/cl.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define SIZE 1024
\end_layout

\begin_layout Plain Layout

// Izvorni tekst programa OpenCL programske jezgre 
\end_layout

\begin_layout Plain Layout

const char* oclSource[] = {   
\end_layout

\begin_layout Plain Layout

  "__kernel void sum_arrays(__global int *in_a, "
\end_layout

\begin_layout Plain Layout

  "                         __global int *in_b, __global int *out_c)", 
  
\end_layout

\begin_layout Plain Layout

  "{",   
\end_layout

\begin_layout Plain Layout

  "    uint n = get_global_id(0);",   
\end_layout

\begin_layout Plain Layout

  "    out_c[n] = in_a[n] + in_b[n];",   
\end_layout

\begin_layout Plain Layout

  "}",
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main (int argc, char **argv) {   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Alokacija memorije za dva ulazna niza   
\end_layout

\begin_layout Plain Layout

  int array_1[SIZE], array_2[SIZE];
\end_layout

\begin_layout Plain Layout

  // Inicijalizacija nasumičnih vrijednosti ulaznih nizova   
\end_layout

\begin_layout Plain Layout

  srandom(time(0));   
\end_layout

\begin_layout Plain Layout

  for (int i=0; i<SIZE; ++i) {       
\end_layout

\begin_layout Plain Layout

    array_1[i] = ((float)random() / RAND_MAX) * 100; 
\end_layout

\begin_layout Plain Layout

    array_2[i] = ((float)random() / RAND_MAX) * 100;     
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Stvaranje OpenCL konteksta za GPU OpenCL uređaje
\end_layout

\begin_layout Plain Layout

  cl_context oclContext = clCreateContextFromType(0, CL_DEVICE_TYPE_GPU,
 
\end_layout

\begin_layout Plain Layout

                                                  NULL, NULL,NULL);
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  // Dobivanje veličine memorije za listu uređaja u kontekstu   
\end_layout

\begin_layout Plain Layout

  size_t paramSize;   
\end_layout

\begin_layout Plain Layout

  clGetContextInfo(oclContext, CL_CONTEXT_DEVICES, 0, NULL, &paramSize);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Dobivanje liste uređaja u kontekstu   
\end_layout

\begin_layout Plain Layout

  cl_device_id* oclDevices = (cl_device_id*)malloc(paramSize);   
\end_layout

\begin_layout Plain Layout

  clGetContextInfo(oclContext, CL_CONTEXT_DEVICES, paramSize, 
\end_layout

\begin_layout Plain Layout

                   oclDevices, NULL);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Stvaranje programskog slijeda u kontekstu za prvi uređaj
\end_layout

\begin_layout Plain Layout

  cl_command_queue oclCommandQueue = 
\end_layout

\begin_layout Plain Layout

          clCreateCommandQueue(oclContext, oclDevices[0], 0, NULL);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Stvaranje memorijskih objekata međuspremnika koje uređaj može
\end_layout

\begin_layout Plain Layout

  // samo čitati; Alokacija memorije na uređaju i kopiranje 
\end_layout

\begin_layout Plain Layout

  // vrijednosti iz ulaznih nizova na domaćinu   
\end_layout

\begin_layout Plain Layout

  cl_mem oclInBuffer_1 = clCreateBuffer(oclContext, CL_MEM_READ_ONLY | 
\end_layout

\begin_layout Plain Layout

        CL_MEM_COPY_HOST_PTR, sizeof(int) * SIZE, array_1, NULL);   
\end_layout

\begin_layout Plain Layout

  cl_mem oclInBuffer_2 = clCreateBuffer(oclContext, CL_MEM_READ_ONLY | 
\end_layout

\begin_layout Plain Layout

        CL_MEM_COPY_HOST_PTR, sizeof(int) * SIZE, array_2, NULL);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Stvaranje memorijskog objekta međuspremnika, 
\end_layout

\begin_layout Plain Layout

  // uređaj može samo pisati u njega   
\end_layout

\begin_layout Plain Layout

  cl_mem oclOutBuffer = clCreateBuffer(oclContext, CL_MEM_WRITE_ONLY, 
\end_layout

\begin_layout Plain Layout

                                       sizeof(int) * SIZE, NULL, NULL);
      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Stvaranje objekta programa iz izvornog programskog koda   
\end_layout

\begin_layout Plain Layout

  cl_program oclProgram = 
\end_layout

\begin_layout Plain Layout

        clCreateProgramWithSource(oclContext, 5, oclSource, NULL, NULL);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Prevođenje programa za sve uređaje u konektstu   
\end_layout

\begin_layout Plain Layout

  // (engl JIT, Just In Time Compilation)   
\end_layout

\begin_layout Plain Layout

  clBuildProgram(oclProgram, 0, NULL, NULL, NULL, NULL);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Stvaranje poveznice sa funkcijom (sum_arrays) unutar programske jezgre
   
\end_layout

\begin_layout Plain Layout

  cl_kernel oclSumArrays = clCreateKernel(oclProgram, "sum_arrays", NULL);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Postavljanje argumenata za programsku jezgru u GPU memoriju   
\end_layout

\begin_layout Plain Layout

  clSetKernelArg(oclSumArrays, 0, sizeof(cl_mem), (void*)&oclInBuffer_1);
   
\end_layout

\begin_layout Plain Layout

  clSetKernelArg(oclSumArrays, 1, sizeof(cl_mem), (void*)&oclInBuffer_2);
   
\end_layout

\begin_layout Plain Layout

  clSetKernelArg(oclSumArrays, 2, sizeof(cl_mem), (void*)&oclOutBuffer);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Pokretanje izvođenja programske jezgre   
\end_layout

\begin_layout Plain Layout

  // Argumentima se specificira programski slijed, objekt 
\end_layout

\begin_layout Plain Layout

  // programske jezgre i veličina indeksnog prostora   
\end_layout

\begin_layout Plain Layout

  size_t WorkSize[1] = {SIZE};   
\end_layout

\begin_layout Plain Layout

  clEnqueueNDRangeKernel(oclCommandQueue, oclSumArrays, 1, NULL, 
\end_layout

\begin_layout Plain Layout

                         WorkSize, NULL, 0, NULL, NULL);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Alokacija memorije na domaćinu za rezultate   
\end_layout

\begin_layout Plain Layout

  // Kopiranje vrijednosti iz objekta međuspremnika u memoriju domaćina
   
\end_layout

\begin_layout Plain Layout

  int array_res[SIZE];   
\end_layout

\begin_layout Plain Layout

  clEnqueueReadBuffer(oclCommandQueue, oclOutBuffer, CL_TRUE, 
\end_layout

\begin_layout Plain Layout

                      0, sizeof(int) * SIZE, array_res,0, NULL, NULL);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Ispis rezultata    
\end_layout

\begin_layout Plain Layout

  for (int i=0; i<SIZE; i++) 
\end_layout

\begin_layout Plain Layout

    printf("%d
\backslash
t%d
\backslash
t%d
\backslash
n", array_1[i], array_2[i], array_res[i]);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Oslobađanje memorije objekata   
\end_layout

\begin_layout Plain Layout

  free(oclDevices);   
\end_layout

\begin_layout Plain Layout

  clReleaseKernel(oclSumArrays);   
\end_layout

\begin_layout Plain Layout

  clReleaseProgram(oclProgram);   
\end_layout

\begin_layout Plain Layout

  clReleaseCommandQueue(oclCommandQueue);   
\end_layout

\begin_layout Plain Layout

  clReleaseContext(oclContext);   
\end_layout

\begin_layout Plain Layout

  clReleaseMemObject(oclInBuffer_1);   
\end_layout

\begin_layout Plain Layout

  clReleaseMemObject(oclInBuffer_2);   
\end_layout

\begin_layout Plain Layout

  clReleaseMemObject(oclOutBuffer);
\end_layout

\begin_layout Plain Layout

  return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Navedeni primjer koristi prvi dostupni GPU od strane 
\emph on
OpenCL
\emph default
-a.
 Za to je potrebno imati instalirane upravljačke programe za grafičke kartice
 koji podržavaju 
\emph on
OpenCL
\emph default
, kao što je prije navedeno.
 To su trenutno 
\shape italic

\begin_inset Quotes eld
\end_inset

novije
\begin_inset Quotes erd
\end_inset


\shape default
 grafičke kartice sa mikroprocesorima kompanija 
\shape italic
Nvidia
\shape default
 i 
\shape italic
AMD/ATI
\shape default
.
 Korištenje GPU-a u primjeru može se jednostavno zamijeniti sa CPU-om.
 
\end_layout

\begin_layout Standard
Za prevođenje izvornog programskog koda u izvršni program se pod 
\emph on
GNU/Linux
\emph default
 operacijskim sustavom koristi 
\shape italic
GNU C Compiler
\shape default
 (
\shape italic
gcc
\shape default
), odnosno njegova varijanta za C++ (
\shape italic
g++
\shape default
).
 Pritom je potrebno definirati putanju do datoteka zaglavlja (engl.
 
\emph on
headers
\emph default
) i povezati ga sa 
\emph on
OpenCL
\emph default
 bibliotekama.
\end_layout

\begin_layout Standard
Primjer za razvojni paket od 
\shape italic
Nvidie
\shape default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

g++ -Wall -I ~/NVIDIA_GPU_Computing_SDK/OpenCL/common/inc/ 
\backslash

\end_layout

\begin_layout Plain Layout

    -lOpenCL opencl-test.cpp -o opencl-test
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Općeniti dijagram tijeka razvoja 
\emph on
OpenCL
\emph default
 aplikacije je prikazan na slici 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL-pseudokod"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/pseudo.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL-pseudokod"

\end_inset

Tijek razvoja 
\emph on
OpenCL
\emph default
 aplikacije
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Druge tehnologije za paralelizaciju
\end_layout

\begin_layout Standard
U ovom je poglavlju dan kratak opis drugih tehnologija za paralelizaciju
 algoritama.
 Navedene su gotovo sve koje su danas relevantne, bez obzira na arhiketuru
 i svrhu kojoj su namijenjene.
 Sve imaju dovoljno dodirnih točaka sa 
\emph on
OpenCL
\emph default
-om za usporedbu, ali nijedna ne omogućava korištenje na heterogenim platformama
, već su sve ciljane na točno određene arhitekture mikroprocesora.
 Svaka tehnologija je ukratko opisana i uspoređena sa 
\emph on
OpenCL
\emph default
-om, istaknute su njihove različitosti, nedostaci i prednosti kako bi se
 istaknula područja u kojima je bolje koristiti jednu ili drugu tehnologiju.
\end_layout

\begin_layout Subsection
CUDA
\end_layout

\begin_layout Standard

\emph on
Compute Unified Device Architecture
\emph default
, skraćeno 
\emph on
CUDA
\emph default
, je sustav razvijen od strane kompanije 
\emph on
Nvidia
\emph default
, a namijenjen izvršavanju programskog koda opće namjene (
\emph on
GP/GPU
\emph default
) na grafičkim mikroprocesorima iste kompanije.
 Na taj način je 
\emph on
Nvidia
\emph default
 omogučila širu primjenu svojih mikroprocesora, osim prikaza zahtjevne računalne
 grafike, za općenito zahtjevne matematičke kalkulacije.
 Sustav je relativno novijeg datuma, prvo javna verzija je postala dostupna
 u veljači 2007.
 godine, podržani su 
\shape italic

\begin_inset Quotes eld
\end_inset

noviji
\begin_inset Quotes erd
\end_inset


\shape default
 mikroprocesori, točnije oni 
\emph on
GeForce8
\emph default
 serije i noviji, a na operacijskim sustavima 
\emph on
GNU/Linux
\emph default
, 
\emph on
Windows
\emph default
 i 
\emph on
Mac OS X
\emph default
.
\end_layout

\begin_layout Standard
Sustav je SIMD modela, točnije SIMT (
\shape italic
engl.
 single instruction, multiple thread
\shape default
), model koji se učestalo koristi za grafičke mikroprocesore zbog njihove
 arhitekture.
 Paralelizirani algoritam se također sastoji od programskih jezgri koje
 se izvode na jezgrama mikroprocesora u velikoj količini dretvi.
 Sustav poznaje dijeljenu memoriju (
\shape italic
\emph on
engl.

\emph default
 shared memory
\shape default
) smještenu na samom GPU-u i lokalnu memoriju
\begin_inset Foot
status open

\begin_layout Plain Layout
Lokalnu memoriju kod sustava 
\emph on
CUDA
\emph default
 ne treba mješati sa lokalnom memorijom 
\emph on
OpenCL
\emph default
-a, već ona odgovara globalnoj memoriji 
\emph on
OpenCL
\emph default
-a, a dijeljena memorija lokalnoj 
\emph on
OpenCL
\emph default
 memoriji.
\end_layout

\end_inset

 koja je smještena na grafičkoj kartici uz GPU.
 Sustav se može koristiti iz mnogih programskih jezika, 
\emph on
C/C++
\emph default
, 
\emph on
Fortran
\emph default
, 
\emph on
Python
\emph default
, 
\emph on
Java
\emph default
 i 
\emph on
Matlab
\emph default
.
 Tekst programa za jezgre se piše u 
\emph on
C
\emph default
-u proširenom za 
\emph on
CUDA
\emph default
-u.
 Sustav koristi modificirani 
\emph on
Open64
\emph default
 programski prevodilac za prevođenje izvornog programskog koda u strojni
 kod nazvan 
\shape italic
Parallel Thread eXecution
\shape default
 (
\shape italic
PTX
\shape default
).
 
\emph on
PTX
\emph default
 je strojni kod koji se izvodi na grafičkim mikroprocesorima od 
\emph on
Nvidie
\emph default
.
 Kroz 
\emph on
CUDA
\emph default
-u je 
\emph on
Nvidia
\emph default
 stvorila sloj apstrakcije nad arhitekturom svojih mikroprocesora, što im
 omogućuje lagano unapređivanje mikroprocesora, a da se ne dovodi u pitanje
 izvođenje i kompatibilnost aplikacija napisanih za 
\emph on
CUDA
\emph default
-u.
 Cilj 
\emph on
CUDA
\emph default
-e je pružiti relativno jednostavan pristup iskorištavanju velikog računalnog
 potencijala GPU-a.
\end_layout

\begin_layout Standard

\emph on
Nvidia
\emph default
 je svoju implementaciju 
\emph on
OpenCL
\emph default
-a temeljila na 
\emph on
CUDA
\emph default
 sustavu, zapravo izvođenje 
\emph on
OpenCL
\emph default
 programskih jezgri je gotovo istovjetno onima u 
\emph on
CUDA
\emph default
-i, time su i performanse oba sustava u istom redu veličine.
 Glavna prednost 
\emph on
OpenCL
\emph default
-a je prenosivost, tj.
 da se tekst programa može izvršavati i na drugim platformama osim GPU-a.
\end_layout

\begin_layout Subsection
ATI Stream SDK
\end_layout

\begin_layout Standard
Početna inačica 
\emph on
Stream SDK
\emph default
 paketa se zvala 
\shape italic
Close To the Metal
\shape default
 (
\shape italic
CTM
\shape default
), a bila je namijenjeno isključivo za 
\emph on
GP/GPU
\emph default
 računarstvo.
 Kako naziv nije zaživio na dulje vrijeme, promijenjen je u 
\emph on
Stream
\emph default
, a ciljano područje primjene je prošireno.
 
\emph on
CTM
\emph default
 je zapravo bio 
\emph on
ATI
\emph default
-jev pandan 
\emph on
CUDA
\emph default
-i od 
\emph on
Nvidie
\emph default
, kako obje kompanije proizvode grafičke mikroprocesore njihova arhitektura
 je uglavnom identična, te su i sustavi iste svrhe, tj.
 omogućiti 
\emph on
GP/GPU
\emph default
.
 Kasnije se 
\emph on
AMD/ATI
\emph default
 odlučio 
\emph on
Stream
\emph default
 iskoristi za implementaciju 
\emph on
OpenCL
\emph default
-a na svojim mikroprocesorima.
\end_layout

\begin_layout Standard
Stream softverski paket osim što implementira 
\emph on
OpenCL
\emph default
 za GPU-ove kompanije 
\emph on
ATI
\emph default
, također je ponudio i 
\emph on
OpenCL
\emph default
 implementaciju za centralne mikroprocesore kompanije 
\emph on
AMD
\emph default
, točnije sve x86_64 mikroprocesore sa SSE3 skupom instrukcija što uključuje
 i 
\emph on
Intel
\emph default
.
 Time je 
\emph on
AMD/ATI Stream
\emph default
 prvi ponudio implementaciju 
\emph on
OpenCL
\emph default
-a za obje platforme na 
\emph on
GNU/Linux
\emph default
 i 
\emph on
Windows
\emph default
 operacijskim sustavima, nakon Appleove implementacije u 
\emph on
Mac OS X
\emph default
-u.
\end_layout

\begin_layout Subsection
MPI
\end_layout

\begin_layout Standard

\emph on
Message Passing Interface
\emph default
 je programsko sučelje (
\shape italic
\emph on
engl.

\emph default
 Application Programming Interface, API
\shape default
) koje omogučava međusobnu komunikaciju više računala, ali i komponenata,
 točnije centralnih mikroprocesora, unutar jednog računala.
 Sustav je namijenjen razvoju aplikacija koje će se izvoditi na skupu računala
 sa raspodijeljenom memorijom, riječ je o SPMD modelu (
\shape italic
\emph on
engl.

\emph default
 Single Process, Multiple Data
\shape default
), tj.
 sva računala izvode isti program, ali na različitim podacima.
 Komunikacija, točnije razmjena podataka, se odvija porukama među procesima
 koji se izvršavaju na centralnim mikroprocesorima odnosno njihovim jezgrama.
 Razmjena poruka između različitih računala se ostvaruje upotrebom TCP mrežnih
 paketa.
 Sustav podržava više tipova komunikacije poput okupljanja procesa u komunikator
e i razmjenu poruka 
\shape italic
jedan-na-jedan
\shape default
, te blokirajuću i neblokirajuću sinkronizaciju.
\end_layout

\begin_layout Standard
Razlikuju se dvije inačice, MPI-1 nastao 1994.
 godine i MPI-2 (1997.
 g.) koji je proširenje MPI-1 inačice, time je zadržana kompatibilnost izvođenja
 MPI-1 programa na MPI-2 sustavu.
 
\emph on
MPI
\emph default
 se nametnuo kao najrašireniji standard u industriji za paralelizaciju izvođenja
 poslova, dvije najpoznatije implementacije su 
\emph on
MPICH
\emph default
 (
\shape italic
http://www.mcs.anl.gov/mpi/mpich/
\shape default
) i 
\emph on
OpenMPI
\emph default
 (
\shape italic
http://www.open-mpi.org/
\shape default
).
 Sam standard je nastao kroz suradnju većeg broja kompanija, te je otvorenog
 tipa.
 Dostupan je u svim relevantnim operacijskim sustavima danas i podržan u
 većini programskih jezika (
\emph on
C
\emph default
, 
\emph on
C++
\emph default
, 
\emph on
Fortran
\emph default
, 
\emph on
Java
\emph default
, 
\emph on
Python
\emph default
, ...), te razvojnih okruženja.
 
\emph on
MPI
\emph default
 je najzastupljeniji u računarstvu visokih performansi (
\emph on
HPC
\emph default
) poput računalnih grozdova (
\shape italic
\emph on
engl.

\emph default
 cluster
\shape default
), spletova (
\shape italic
\emph on
engl.

\emph default
 grid
\shape default
) i općenito superračunala (
\shape italic
\emph on
engl.

\emph default
 supercomputer
\shape default
).
\end_layout

\begin_layout Standard
Nedostak 
\emph on
MPI
\emph default
-a u odnosu na 
\emph on
OpenCL
\emph default
 su ciljane arhitekture, tj.
 
\emph on
MPI
\emph default
 je namijenjen isključivo za centralne mikroprocesore arhitektura x86 i
 x86_64, a 
\emph on
OpenCL
\emph default
 općenito za heterogene platforme (CPU, GPU, ...).
 
\emph on
MPI
\emph default
 izvodi poslove kroz pokretanje procesa, dok se 
\emph on
OpenCL
\emph default
 više oslanja na dretve, što je učinkovitije kod višejezgrenih mikroprocesora,
 poput GPU-a i višejezgrenih CPU-a.
 Nedostatak 
\emph on
OpenCL
\emph default
-a je što standard ne specificira nikakvu razmjenu podataka između više
 računala, već samo između uređaja unutar jednog računala, također je 
\emph on
MPI
\emph default
 daleko stariji standard i time znatno rašireniji, što 
\emph on
OpenCL
\emph default
-u ne treba uzimati kao nedostatak iz razloga što još nije ni u potpunosti
 podržan na svim platformama.
 
\end_layout

\begin_layout Standard
Iako su oba sustava osmišljena sa različitim ciljevima dodirna točka im
 je paralelizacija algoritama koji će se izvoditi unutar jednog računala,
 te se oba mogu koristiti u tu svrhu.
\end_layout

\begin_layout Subsection
OpenMP
\end_layout

\begin_layout Standard

\emph on
Open Multi-processing
\emph default
 je poput 
\emph on
MPI
\emph default
-a programsko sučelje za paralelizaciju algoritama, ali temeljeno na zajedničkoj
 memoriji i višedretvenosti (
\shape italic
\emph on
engl.

\emph default
 multithreading
\shape default
).
 Za razliku od 
\emph on
MPI
\emph default
-a barata sa dretvama umjesto procesa, te je namijenjeno izvedbi na jednom
 računalu, a ne skupu računala.
 Standard je također otvorenog tipa i definiran od strane više kompanija
 na području sklopovlja i softvera.
\end_layout

\begin_layout Standard
Moguća je kombinacija sa sustavom 
\emph on
MPI
\emph default
 kako bi se dobio hibridni model kojim se kroz 
\emph on
MPI
\emph default
 razmjenjuju poruke između više računala namijenjene 
\emph on
OpenMP
\emph default
 programima na svakom računalu.
 
\emph on
OpenMP
\emph default
 se temelji na višedretvenosti, tj.
 omogućava stvaranje paralelnih algoritama tako da se poslovi ili podaci
 raspodijele između više dretvi koje se paralelno izvode na dostupnoj platformi
 odnosno jezgrama CPU-a.
 Sustav je također široke primjene i podržan na večini operacijskih sustava
 i programskih jezika, te razvojnih okružja.
 Prva inačica se pojavila 1997.
 godine, a zadnja (3.0) 2008.
 godine.
\end_layout

\begin_layout Standard

\emph on
OpenMP
\emph default
 je dosta bliži svojim načinom rada 
\emph on
OpenCL
\emph default
-u od 
\emph on
MPI
\emph default
-a.
 Oba sustava barataju sa dretvama i zajedničkom memorijom, tj.
 
\emph on
OpenCL
\emph default
 barata zajedničkom memorijom unutar istog 
\emph on
OpenCL
\emph default
 uređaja.
 Prednost 
\emph on
OpenCL
\emph default
-a je opet podrška različitim platformama, dok 
\emph on
OpenMP
\emph default
 cilja samo na CPU.
 Oba sustava pružaju visoke performanse i relativno jednostavnu paralelizaciju
 algoritama, te su prenosivi.
 
\emph on
OpenMP
\emph default
 je rašireniji i podržaniji standard iz razloga što je dulje u primjeni,
 što se ne može pripisati kao manjak 
\emph on
OpenCL
\emph default
-u.
 Paralelizacija je ipak nešto složenija na 
\emph on
OpenCL
\emph default
-u iz razloga podrške različitim platformama, tj.
 moraju se prvo stvoriti programski konteksti i slijedovi, memorijski objekti
 i programske jezgre.
 
\emph on
OpenMP
\emph default
 je zapravo proširenje već postojećih programskih prevodilaca, poput 
\emph on
GCC
\emph default
-a (
\shape italic
\emph on
engl.

\emph default
 GNU C Compiler
\shape default
), te mu se kroz predprocesorske naredbe u programskom kodu specificiraju
 dijelovi koji se trebaju izvoditi paralelnog odnosno višedretveno.
\end_layout

\begin_layout Subsection
Cell BE
\end_layout

\begin_layout Standard

\emph on
Cell Broadband Engine
\emph default
 je nastao na sasvim novoj arhitekturi mikroprocesora 
\shape italic
Cell
\shape default
 (
\shape italic
http://www.research.ibm.com/cell/
\shape default
), razvijenih od strane 
\emph on
IBM
\emph default
-a, 
\emph on
Sonya
\emph default
 i 
\emph on
Toshibe
\emph default
.
 Mikroprocesor je kombinacija uobičajenih mikroprocesora opće namjene i
 specijaliziranih mikroprocesora, poput onih grafičkih od 
\emph on
Nvidie
\emph default
 i 
\emph on
ATI
\emph default
-a.
 Sastoji se od jedne jezgre opće namjene, zvane 
\emph on
PPE
\emph default
, koja je bazirana na 
\emph on
PowerPC
\emph default
 arhitekturi, te osam jezgri, zvanih 
\emph on
SPE
\emph default
, koje su specijalizirane za brzu obradu velikih količina podataka.
 U praksi se mikroprocesor pokazao izuzetno brzim u određenim poljima spram
 mikroprocesora opće namjene.
\end_layout

\begin_layout Standard
Sustav pruža programsko sučelje za upravljanje mikroprocesorima, podržani
 su programski jezici 
\emph on
C
\emph default
 i 
\emph on
C++
\emph default
.
 Posao se izvodi tako da se 
\emph on
PPE
\emph default
 jezgra koristi za operacijski sustav i raspodjelu poslova i njihovu sinkronizac
iju, koji se zatim izvode na 
\emph on
SPE
\emph default
 jezgrama.
 
\emph on
Cell
\emph default
 mikroprocesore se može pronaći u 
\emph on
Sony PlayStation3
\emph default
 igračim konzolama, superračunalima i poslužiteljima razvijenim od strane
 
\emph on
IBM
\emph default
-a, te specijaliziranim karticama koje se mogu ugraditi u standardno računalo.
 Kako je riječ o poprilično specifičnoj tehnologiji koja se oslanja isključivno
 na 
\emph on
Cell
\emph default
 mikroprocesore, njezina zastupljenost je ograničena.
 Šira primjena je ostvarena kroz 
\emph on
GNU/Linux
\emph default
 distribuciju 
\emph on
Yellow Dog Linux
\emph default
 koja se može instalirati na 
\emph on
PlayStation3
\emph default
, te je čest slučaj povezivanje više konzola u grozd, time se za relativno
 malu cijenu mogu ostvariti izrazito velike računalne performanse.
 
\end_layout

\begin_layout Standard

\emph on
Cell BE
\emph default
 se u praksi pokazao kao izrazito dobra tehnologija što se tiče performansi,
 na kojoj 
\emph on
IBM
\emph default
 i dalje radi te ju unapređuje.
 Nažalost tehnologija nije lako dostupna široj populaciji jer ovisi isključivo
 o 
\emph on
Cell
\emph default
 mikroprocesorima, najjednostavniji i najjeftiniji način je nabavka 
\emph on
PlayStation3
\emph default
 konzole.
 Kako 
\emph on
IBM
\emph default
 isto sudjeluje u razvoju 
\emph on
OpenCL
\emph default
 sustava, za očekivati je da će uskoro izdati podršku za 
\emph on
Cell
\emph default
 mikroprocesore, čime će se i njihova primjena raširiti.
\end_layout

\begin_layout Subsection
DirectCompute
\end_layout

\begin_layout Standard

\emph on
DirectCompute
\emph default
 je tehnologija namijenjena za 
\emph on
GP/GPU
\emph default
, a razvijena od strane 
\emph on
Microsofta
\emph default
.
 Sadržana je u 
\emph on
DirectX
\emph default
 sustavu verzije 11, koji se pojavio krajem 2009.
 godine za operacijske sustave 
\emph on
Windows Vista
\emph default
 i 
\emph on
Windows 7
\emph default
.
 Podržani su grafički mikroprocesori koji podržavaju 
\emph on
DirectX 10
\emph default
 i 
\emph on
11
\emph default
.
 
\emph on
Nvidia
\emph default
 i 
\emph on
AMD
\emph default
 su već najavili svoju podršku ovoj tehnologiji.
 Kako je tehnologija nešto novija čak i od 
\emph on
OpenCL
\emph default
-a teško je dati neku širu analizu, nedostaci su podrška samo za GPU, te
 ograničenost na novije verzije 
\emph on
Windows
\emph default
 operacijskog sustava.
\end_layout

\begin_layout Subsection
Intel Ct
\end_layout

\begin_layout Standard

\emph on
Intel
\emph default
 je 2009.
 godine, kupnjom kompanije 
\emph on
RapidMind
\emph default
, stekao vlasništvo i nad tehnologijom 
\emph on
RapidMind Multi-core Development Platform
\emph default
.
 Riječ je o platformi koja se sastoji od 
\emph on
C++
\emph default
 biblioteka koje omogučuju podatkovnu paralelizaciju algoritama, ciljane
 platforme su 
\emph on
CPU
\emph default
, 
\emph on
GPU
\emph default
 i 
\emph on
Cell
\emph default
.
 
\emph on
Intel
\emph default
 je na temelju te tehnologije izgradio svoju 
\emph on
Ct
\emph default
 tehnologiju, za koju navodi kako je tekst programa prenosiv i kroz sustav
 izvodiv na heterogenim platformama, jednostavan za implementaciju željenih
 aplikacija jer se oslanja na 
\emph on
C++
\emph default
, te visokih performansi.
 
\end_layout

\begin_layout Standard
Kako je sustav trenutno u fazi testiranja (beta) veće usporedbe sa drugim
 tehnologijama nisu moguče.
 U svakom slučaju treba pratiti razvoj ovog sustava/platforme jer po opisu
 djeluje poprilično slično 
\emph on
OpenCL
\emph default
-u, zapravo je uz 
\emph on
OpenCL
\emph default
 jedini sustav koji cilja na heterogene platforme.
 Moguća mana u razvoju bi mu mogla biti ovisnost o jednoj kompaniji, dok
 je 
\emph on
OpenCL
\emph default
 nastao kroz konzorcij u kojem sudjeluju svi proizvođači sklopovlja.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Arhitekture mikroprocesora
\end_layout

\begin_layout Standard
Pojavom osobnog računala (
\shape italic
\emph on
engl.

\emph default
 personal computer, PC
\shape default
) i njegovom popularizacijom 80' i 90' godina prošlog stoljeća je računalna
 snaga mikroprocesora postala dostupna i široj populaciji.
 Do onda su 
\shape italic

\begin_inset Quotes eld
\end_inset

brza
\begin_inset Quotes erd
\end_inset


\shape default
 (super)računala bila dostupna samo uskim akademskim krugovima, te zatvorenim
 ustanovama poput nekih kompanija i vladinih agencija.
 Kroz vrijeme su se razni proizvođači mikroprocesora natjecali tko će ponuditi
 brži, učinkovitiji i povoljniji mikroprocesor kako bi osvojili veći dio
 tržišta.
\end_layout

\begin_layout Standard
Pravilo koje poprilično precizno opisuje napredak razvoja mikroprocesora
 je Mooreov zakon
\begin_inset Foot
status open

\begin_layout Plain Layout
Gordon Moore je jedan od suosnivača kompanije Intel, a svoje zapažanje je
 iznio oko 1970.
 godine.
\end_layout

\end_inset

, a kaže da se broj tranzistora na mikroprocesoru udvostruči svaka 24 mjeseca.
 Zakon se pokazao ispravnim sve do danas, a vjerovatno će se nastaviti još
 nekoliko godina dok se ne dođe do fizičke granice smanjivanja tranzistora
 i problema pretjerane disipacije topline.
 
\end_layout

\begin_layout Standard
Time su broj tranzistora i radni taktovi dulji niz godina samo rasli, pojavljiva
le se nove arhitekture, postojeće arhitekture se proširivale, ali neke i
 padale u zaborav zajedno sa kompanijama koje su stajale iza njih.
 Također se i svrha mikroprocesora mijenjala, dok se je prije cjelokupna
 obrada podataka izvodila samo na centralnim mikroprocesorima, u drugoj
 polovici 90' su se pojavili i grafički mikroprocesori drugačije svrhe i
 arhitekture.
 
\end_layout

\begin_layout Standard
Danas osobna računala ostvaruju rezultate kakve su prije par desetak godina
 mogla samo superračunala.
 Uobičajeno je imati višejezgreni centralni mikroprocesor u svoj računalu,
 te u većini slučajeva i grafički mikroprocesor sa mogučnošću akceleracije
 3D grafike.
 Postavlja se pitanje kako u potpunosti, na što jednostavniji način, iskoristi
 taj potencijal, bilo da se radi o računarstvu visokih performansi ili nekim
 općenitijim radnjama, poput dekodiranja videa visoke kvalitete, sve zahtjevniji
m web aplikacijama ili pak računalnim igrama.
 
\end_layout

\begin_layout Standard
Bitno je napomenuti kako porast potrebe za računalnom snagom, recimo u slučaju
 web aplikacija, često nije uzrokovan kompeksnošću algoritama, već visokim
 stupnjem programske apstrakcije.
 Ako se neka aplikacija realizira na niskom sloju, poput strojnog jezika
 ili 
\emph on
C
\emph default
-a, može se očekivati velika učinkovitost, ali ako se radi o aplikaciji
 napisanoj u nekom dinamičnom jeziku višeg razreda koji komunicira sa nižim
 slojevima kroz nekakvo virtualno sučelje, performanse će naravno padati,
 čak i za nekoliko redova veličine.
 Naravno odabir višeg programskog jezika ima prednost kraćeg vremena potrebnog
 za razvoj, veće fleksibilnosti u naknadnim promjenama i prenosivosti.
 Zato je bitno prilikom razvoja neke aplikacije ili sustava dobro procjeniti
 odabir programskog jezika, moguće je i njihovo kombiniranje ovisno o kritičnim
 djelovima aplikacije.
 Dobar primjer je korištenje 
\emph on
pyOpenCL
\emph default
 implementacije za postavljanje okruženja za izvođenje programskih jezgri,
 dok su one i dalje zadržane u 
\emph on
OpenCL C
\emph default
-u kako bi postizale visoke performanse.
\end_layout

\begin_layout Standard
Zadnjih godina je poseban naglasak stavljen na paralelizaciju obrade podataka
 na mikroprocesoru.
 Razlog je dostizanje granice postojeće tehnologije prilikom izvođenja slijednog
 niza naredbi, to je potaknulo pojavu višejezgrenih centralnih mikroprocesora,
 dok su grafički mikroprocesori u samom početku više orijentirani na paralelizam
 zbog primarne svrhe kojoj su namijenjeni.
 Proces paralelizacije slijednog algoritma nije jednostavan, neki alogritmi
 se po svojoj prirodi trivijalno paraleliziraju, dok neke uopće nije moguće.
 Danas ne postoji nikakvo posve automatizirano rješenje navedenog problema
 već pada u domenu programera, a programski prevodioci mogu do neke mjere
 učinkovito prevesti izvorni tekst programa u različite strojne kodove ovisno
 o ciljanoj platformi, npr.
 
\emph on
OpenCL
\emph default
 
\shape italic
Just-in-Time
\shape default
 prevodilac.
 Sama učinkovitost optimiranja prevođenja programskog koda u niz instrukcija
 je bitna odlika prevodilaca.
\end_layout

\begin_layout Standard
Ovdje će detaljnije biti opisani centralni mikroprocesori arhitekture x86,
 odnosno njene 64-bitne varijante x86_64, kakve danas nalazimo u svim osobnim
 računalima, ali i superačunalima.
 Grafički mikroprocesori će biti ilustrirani na primjeru kompanije 
\emph on
Nvidia
\emph default
, te 
\emph on
Cell
\emph default
 mikroprocesor kompanije 
\emph on
IBM
\emph default
, za koje bi se moglo reći da su hibrid prethodne dvije arhitekture.
 Riječ je o mikroprocesorima koji su najrašireniji i lako dostupni, a visokih
 performansi, naravno tu priča o mikroprocesorima ne staje, ali prije navedeni
 ulaze u područje koje je zanimljivo za paralelizaciju algoritama.
\end_layout

\begin_layout Standard
Osim ovdje navedenih danas su dostupne arhitekture poput 
\emph on
ARM
\emph default
-a koji se nalaze u mobilnim uređajima i 
\emph on
MIPS
\emph default
-a koja je česta kod ugradbenih i mrežnih računala, poput usmjerivača mrežnog
 prometa (engl.
 
\emph on
router
\emph default
).
 Također su još uvijek žive neke arhitekture namijenjene isključivo poslužitelji
ma, poput 
\emph on
PA-RISC
\emph default
 mikroprocesora kompanije 
\emph on
HP
\emph default
 i 
\emph on
Sparc
\emph default
 od 
\emph on
Sun Microsystemsa
\emph default
.
\end_layout

\begin_layout Standard
Cilj je ukratko opisati trenutno dostupne arhitekture na kojima su ostvareni
 mikroprocesori visokih performansi, dati kratak uvid u neke arhitekture
 koje tek dolaze, te pokušat pretpostaviti u kojem će se smjeru razvijati
 naše aplikacije i njima dostupne platforme.
 Područje mikroprocesora je danas izuzetno zanimljivo jer je na pomolu redefinir
anje pojmova CPU i GPU, barem načina na koji ih danas koristimo.
 Osnovno poznavanje arhitektura mikroprocesora je bitno za kasniju analizu
 rezultata 
\emph on
OpenCL
\emph default
 testova, te općenito za odabir arhitekture koja će učinkovitije izvoditi
 željene algoritme.
\end_layout

\begin_layout Subsection
Centralni mikroprocesor - CPU
\end_layout

\begin_layout Standard
Razvoj mikroprocesora je još započeo 60' godina prošlog stoljeća, od onda
 je ostvaren ogroman napredak u njihovom razvoju, vjerovatno i najveći uzevši
 bilo koju industriju u obzir.
 Osnovni princip funkcioniranja je uglavnom ostao isti do danas, a temelji
 se na Von Neumannovoj arhitekturi.
 Mikroprocesor dohvaća naredbe redom iz memorije uz pomoć programskog brojila
 (
\shape italic
\emph on
engl.

\emph default
 program counter
\shape default
), dekodira naredbu, ovisno o njoj dohvati podatke u memoriji, točnije registrim
a unutar samog mikroprocesora, te je izvede na aritmeto-logičkoj jedinici,
 dobivene podatke zapiše nazad na neku memorijsku lokaciju.
 Primjer izvođenja jedne instrukcije je prikazan slici, za jednu instrukciju
 je potrebno pet ciklusa.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/pipe1.png
	lyxscale 50
	width 14cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Slijedno izvođenje instrukcija
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Proizvođači mikroprocesora su se godinama, osim unapređivanja arhitekture,
 oslanjali i na konstantno podizanje radnog takta kako bi se postizale bolje
 performanse.
 Svoju ulogu je igrao i marketing jer je oznaka radnog takta ukazivala na
 snagu mikroprocesora u odnosu na druge, tako da su je proizvođači isticali
 uz naziv mikroprocesora.
 Međutim podizanje radnog takta se zaustavilo prije par godina na okvirno
 3 GHz i danas su uglavnom na tržištu x86_64 mikroprocesori radnog takta
 između 2 i 3 GHz.
 Razlog tomu je da viši radni takt znači i veće zagrijavanje, a veliku količinu
 topline je teško odvoditi sa tako malene površine poput mikroprocesora.
 Za ilustraciju je dovoljno zamisliti potrošnju nekog mikroprocesora od
 100 watta sa otprilike svega 1cm
\begin_inset Formula $^{\text{}2}$
\end_inset

 površine, a fizička veličina mikroprocesora i cijelog računala mora biti
 manjih dimenzija zbog latencije i refleksija signala, te drugih neželjenih
 pojava.
 Zbog toga radni takt više nije glavni faktor podizanja brzine mikroprocesora,
 već su se proizvođači orijentirali na paralelizaciju rada i višejezgrenost,
 što povlači problem paralelizacije algoritama koji često nije odveć trivijalan.
 Problem radnog takta i topline vrijedi za sve elektroničke komponente općenito.
 Još jedan problem je što rast radnog takta mikroprocesora nije pratila
 i memorija, tako da je pristup memoriji u nekim slučajevima isto usko grlo
 sustava, što je još jedan od razloga što veće pričuvne memorije (
\shape italic
\emph on
engl.

\emph default
 cache
\shape default
) na samom mikroprocesoru, koja opet opet zauzima dosta veliku fizičko površinu
 odnosno broj tranzistora.
\end_layout

\begin_layout Standard
Kako nikad neće postojati mikroprocesor dovoljno brz za sve potrebe, tj.
 u tom slučaju bi trebao biti beskonačno brz, logično je korištenje više
 mikroprocesora zajedno.
 Jedan od načina je smještanje više mikroprocesora u jedno računalo, no
 i to ima svoje granice zbog troškova sinkronizacije, fizičke veličine sabirnica
 koje ih povezuju, hlađenja, cijene i drugih praktičnih razloga.
 Tipično je imati osobno računalo sa jedim mikroprocesorom, dok ona poslužiteljs
ka mogu po 2, 4, 8 i u nekim specifičnim slučajevima više.
 Slijedeći korak je povezivanje više računala u grozdove, te raspoređivanje
 poslova po njima uz pomoć sustava poput 
\emph on
MPI
\emph default
.
 Prilikom paralelnog izvođenja programa svakako treba uzeti u obzir i trošak,
 preciznije vrijeme, komunikacije, koji je unutar jednog računala izuzetno
 malo, ali između više računala može imati značajan utjecaj na cjelokupne
 performanse.
\end_layout

\begin_layout Standard
Zbog prije navedenih problema današnji mikroprocesori su izuzetno kompleksni,
 sadrže čak preko 2 milijarde tranzistora, te imaju cijeli niz ugrađenih
 tehnika kako bi im se pospješila učinkovitost.
 Posjeduju velik skup instrukcija koje izvode (CISC arhitektura), mnogo
 registara i velike količine pričuvne memorije na samom mikroprocesoru,
 uobičajeno 1 do 8MB.
 Pristup pričuvnoj memoriji je daleko brži nego radnoj memoriji računala.
 Kako se visinom radnog takta dosegao maksimum slijednog izvođenja naredbi,
 već dulje vrijeme se veći naglasak stavlja na paralelizam koji se ostvaruje
 tehnikama poput cjevovoda (
\shape italic
\emph on
engl.

\emph default
 pipelining
\shape default
), superskalarnosti (
\shape italic
\emph on
engl.

\emph default
 superscalar
\shape default
), višedretvenosti (
\shape italic
\emph on
engl.

\emph default
 multithreading
\shape default
), a u zadnje vrijeme i višejezgrenosti (
\shape italic
\emph on
engl.

\emph default
 multicore
\shape default
).
 
\end_layout

\begin_layout Subsubsection
Cjevovodi i superskalarnost
\end_layout

\begin_layout Standard
Za izvedbu jedne instrukcije mikroprocesoru trebaju jedan ili više radnih
 perioda.
 Trajanje instrukcije se nikako ne može smanjiti na manje od jednog takta,
 ali je moguće pokušati izvesti u jednom periodu više različitih instrukcija.
 Pristup koji to omogućuje se naziva instrukcijski cjevovod (
\shape italic
\emph on
engl.

\emph default
 instruction pipeline
\shape default
), koji se pojednostavnjeno može zamisliti kao započinanje obrade jedne
 instrukcije dok druga nije završila, tako u nekoliko razina.
 Problemi koji se javljaju je mogučnost nejednolikog broja perioda za izvršenje
 jedne instrukcije, pa za to vrijeme ostale čekaju, te ovisnost izvođenja
 jedne instrukcije o rezultatu prethodne.
 Ilustracija prikazuje princip cjevovoda duljine pet razina, za razliku
 od 
\shape italic

\begin_inset Quotes eld
\end_inset

običnog
\begin_inset Quotes erd
\end_inset


\shape default
 slijednog izvođenja u kojem za jednu instrukciju treba pet ciklusa, u ovom
 primjeru se u idealnom slučaju može izvesti jedna instrukcija u jednom
 ciklusu.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/pipe2.png
	lyxscale 50
	width 14cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cjevovodi CPU-a
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sljedeći korak je superskalarnost koja uključuje dulje cjevovode sa više
 identičnih jedinica koje obrađuju instrukcije.
 Na taj način se pokušava više instrukcija izvesti u jednakom vremenskom
 periodu, a glavnu ulogu tu preuzima raspodjeljivač instrukcija (
\shape italic
\emph on
engl.

\emph default
 dispatcher
\shape default
) koji odlučuje kako će preraspodijeliti instrukcije po cjevovodima.
 Na slici je vidljivo kako u idealnom slučaju mikroprocesor može efektivno
 izvesti dvije instrukcije u jednom ciklusu.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/pipe3.png
	lyxscale 50
	width 14cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Superskalarnost CPU-a
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Osim ove dvije bitne karakteristike, današnji mikroprocesori posjeduju i
 druge napredne tehnologije, poput predviđanja granjanja (
\shape italic
\emph on
engl.

\emph default
 branch prediction
\shape default
), brzog prebacivanja između dretvi (
\shape italic
\emph on
engl.

\emph default
 out of order exectution
\shape default
), te uvođenja novih setova instrukcija.
 Skup instrukcija SSE omogučava vektorsku obradu podataka (SIMD), te su
 tu još i posebne instrukcije za virtualizaciju i mnoge druge.
\end_layout

\begin_layout Standard
Danas svi centralni mikroprocesori u svojoj realizaciji posjeduju cjevovode
 i superskalarnost.
 Bitno je napomenuti kako na navedene principe programer nema utjecaj, tj.
 njih logika mikroprocesora sama primjenjuje na slijedno izvođenje algoritama
 i tako pokušava u jednom radnom periodu izvesti što više instrukcija, što
 u nekim slučajevima znatno unapređuje brzinu, dok kod nekih drugih baš
 i ne.
 Za ostvarenje logike CPU-a koja upravlja navedenim tehnikama je potrebna
 znatna količina tranzistora, dok je GPU 
\shape italic

\begin_inset Quotes eld
\end_inset

jednostavniji
\begin_inset Quotes erd
\end_inset


\shape default
 što se logike tiče, pa je veći broj tranzistora iskorišten za ALU jedinice,
 što mu omogućuje daleko brže matematičke kalkulacije u mnogo dretvi.
\end_layout

\begin_layout Subsubsection
Višedretvenost i višejezgrenost
\end_layout

\begin_layout Standard
Na današnjim računalima nalazimo pokrenute na desetke ili stotine programskih
 procesa od kojih svaki može imati više dretvi, dok se za redoslijed i priorite
 njihovog izvođenja brinu raspoređivači unutar operacijskog sustava (
\shape italic
\emph on
engl.

\emph default
 scheduler
\shape default
).
 Konkretan primjer upotrebe dretvi je situacija u kojoj jedna obavlja posao
 dok druga dohvaća nove podatke iz memorije.
 Višedretvenost je sposobnost mikroprocesora da odjednom izvodi više od
 jedne programske dretve, po principu da se mikroprocesor može u svega par
 ciklusa prebaciti sa izvođenja jedne dretve na drugu ili da paralelizira
 njihovo izvođenje, tj.
 dijelova koje može.
 Svi današnji operacijski sustavi za osobna računala već dulji niz godina
 mogu paralelno izvoditi procese i dretve, te na taj način iskorištavaju
 mogućnosti mikroprocesora.
 
\emph on
Intel
\emph default
 je u svojem 
\emph on
Pentium 4
\emph default
 mikroprocesoru uveo tehnologiju nazvanu 
\shape italic
HyperThreading
\shape default
 (
\emph on
HT
\emph default
), koja je jedan mikroprocesor operacijskom sustavu predstavljala kao dva.
 Učinkovitost je ostala upitna te je 
\emph on
HT
\emph default
 isključen iz kasnijih generacija mikroprocesora, da bi se u onim novijim
 opet uključio.
 
\end_layout

\begin_layout Standard
Višejezgrenost je aktualniji trend od prije opisanih, kada se dostigla fizička
 granica radnog takta i s time problema odvođenja topline, proizvođači su
 se zadržali na istom radnom taktu, ali su počeli daljni rast broja tranzistora
 iskorištavati za ostvarenje više procesorskih jezgri.
 Time korisnici efektivno dobivaju dva ili više mikroprocesora na raspolaganje,
 a fizički je riječ o više jezgi unutar jednog mikroprocesora koje dijele
 zajedničku pričuvnu memoriju.
 Do pojave višejezgrenih CPU-a je jedini način posjedovanja više od jednog
 CPU-a u jednom osobnom računalu bio posjedovanje poslužitelja koji su su
 naravno većeg cjenovnog ranga.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Danas na raspolaganju imamo centralne mikroprocesore arhitekture x86_64
 kompanija 
\emph on
Intel
\emph default
 i 
\emph on
AMD
\emph default
 koji su međusobno kompatibilini, tj.
 barataju sa istim skupovim instrukcija uz neke manje razlike, sadrže po
 nekoliko jezgri, veće količine pričuvne memorije i napredne načine optimiranja
 izvođenja programskog koda.
 Centralni mikroprocesori su opće namjene što naravno povlaći određene mane,
 imaju velik skup instrukcija i moraju zadržavati kompatibilnost unazad
 jer se i tekst programa napisan prije 20 godina mora izvoditi na novom
 mikroprocesoru.
 Iz tog razloga su izrazito kompleksni, što povlači određeni danak u performansa
ma na specifičnija područa, jer je njihova namjena općenito obavljanje rada
 u računalu, poput operacijskog sustava i korisničkih aplikacija, dok su
 grafički mikroprocesori usmjereni na paralelni rad nad većim količinama
 podataka.
\end_layout

\begin_layout Subsection
Grafički mikroprocesor - GPU
\end_layout

\begin_layout Standard
Značajniji razvoj grafičkih mikroprocesori je, za razliku od centralnih
 mikroprocesora, krenuo mnogo kasnije, tek u drugoj polovici 90' godina,
 za potrebe ubrzanja prikaza trodimenzionalne grafike.
 Iz tog razloga je njihova arhitektura poprilično drugačija od CPU-a, namjena
 im je što brži prikaz 3D grafike što je zahtjeva što brže obavljanje matematičk
ih operacija, veliku propusnost i paralelizaciju.
 
\end_layout

\begin_layout Standard
Dok CPU pokušava cjevovodima i superskalarnošću paralelizirati izvođenje
 instrukcija, a tek zadnjih godina višejezgrenošću, grafički mikroprocesori
 su u samom početku dizajnirani tako da imaju više 
\shape italic

\begin_inset Quotes eld
\end_inset

manjih
\begin_inset Quotes erd
\end_inset


\shape default
 jezgri i da se drže SIMD odnosno SIMT principa.
 Prva bitna razlika je da CPU ima veliku količinu pričuvne memorije što
 uzima velik broj tranzistora, dok kod GPU-a to nije slučaj, tako da mu
 više tranzistora ostaje za ALU jedinice.
 U slučaju 
\emph on
Nvidie
\emph default
 je GPU organiziran tako da se sastoji od procesora dretvi (
\shape italic
\emph on
engl.

\emph default
 thread processor
\shape default
) koji su organizirani u grupe, svaka grupa ima svoju dijeljenu memoriju
 (
\shape italic
\emph on
engl.

\emph default
 shared memory
\shape default
) koja odgovara pričuvnoj memoriji kod CPU-a.
 Svaki procesor dretvi u grupi ima pristup istoj dijeljenoj memoriji, ali
 ne i memoriji druge grupe.
 Također svaki procesor dretvi može simultano izvršavati veći broj dretvi.
 
\emph on
Nvidia
\emph default
 grupe procesora dretvi naziva multiprocesor, a svi noviji GPU-ovi imaju
 više multiprocesora, za primjer korištena 
\emph on
Nvidia
\emph default
 
\emph on
FX570m
\emph default
 se sastoji od četiri multiprocesora.
 
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/cpu-gpu.png
	lyxscale 50
	width 14cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
CPU - GPU usporedba
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Konkretan primjer je 
\emph on
GeForce8
\emph default
 mikroprocesor (2006.
 godina) koji ima 128 procesora dretvi, svakih 8 je u istoj grupi te dijele
 po 16kB dijeljene memorije, a svaki može istovremeno izvršavati po 96 dretvi.
 Time dolazimo do ukupnog broja od 12,288 dretvi koje mikroprocesor može
 istovremeno izvršavati.
 Jasno je kako GPU spram CPU-a ima daleko veću mogučnost paralelnog izvršavanja
 programskog koda, s druge strane mu je mana mala pričuvna odnosno dijeljena
 memorija.
 Iz tog razloga će se GPU dobro ponašati za obradom velike količine kontinuirani
h podataka, poput 3D grafike, obrade videa i zvuka, te općenito paraleliziranih
 algoritama koji zahtjevaju mnogo matematičkih operacija.
 
\end_layout

\begin_layout Standard
GPU ostvaruje jako slabe performanse ako program koji izvodimo nije visoko
 paraleliziran, razlog je što posjeduje veliku količinu procesora dretvi
 koji sami po sebi nisu brzi, ali kako ih ima puno njihova ukupna učinkovitost
 drastično raste.
 GPU također izvodi po nekoliko dretvi na jednom procesoru dretvi iz razloga
 što dok jednu obrađuje, priprema memoriju za sljedeću, princip je donekle
 sličan cjevovodima kod CPU-a, te se naziva prikrivanje latencije (
\shape italic
\emph on
engl.

\emph default
 latency hiding
\shape default
) pristupa memoriji.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/gpu-latency.png
	lyxscale 50
	width 14cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Prikrivanje latencije kod GPU-a
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Danas se na području grafičkih mikroprocosora orijentiranih na 3D performanse
 natječu kompanije 
\emph on
Nvidia
\emph default
 i 
\emph on
AMD/ATI
\emph default
.
 GPU-ovi također kao i CPU-ovi imaju po par milijardi tranzistora, radni
 takt im najčešće ne prelazi 1 GHz, a proizvođači se hvale kako su u vršnim
 performansama po čak nekoliko puta brži od CPU-a, naravno pod određenim
 tipovima opterečenja.
 Prije par godina su proizvođači uvidjeli da potencijal svojih GPU-ova mogu
 iskoristiti i u šire svrhe od samog prikaza 3D grafike, te pružili korisnicima
 sučelja za njihovo iskorištavanje, poput prije opisane 
\emph on
CUDA
\emph default
-e i 
\emph on
Streama
\emph default
.
 Nvidia je čak ponudila i grafičke kartice koje uopće nisu namijenjene prikazu
 slike, već sadrže po nekoliko grafičkih mikroprocesora visoke klase i služe
 isključivo za paralelnu obradu podataka kroz 
\emph on
CUDA
\emph default
-u ili 
\emph on
OpenCL
\emph default
, riječ je o 
\emph on
Tesla
\emph default
 seriji grafičkih kartica sa po tisuću i više jezgri.
 Tako je poprilično velika računalna snaga postala lakše dostupna, jer jedna
 takva kartica uvelike nadmašuje i najskuplje poslužitelje sa po nekoliko
 CPU-a, naravno u užem području primjene.
 
\end_layout

\begin_layout Standard
Za razliku od razvoja programa za CPU, kod GPU treba voditi računa o nekoliko
 principa kojima se značajno poboljšavaju performanse, poput da je njegova
 pričuvna memorija mala, te da ju treba 
\shape italic

\begin_inset Quotes eld
\end_inset

pažljivo
\begin_inset Quotes erd
\end_inset


\shape default
 koristi jer je pristup njoj daleko brži nego radnoj memoriji, treba minimizirat
i prijenos podataka između domaćina (CPU + radna memorija) i GPU-a jer je
 sabirnica kojom je povezan često usko grlo sustava, osigurati velik broj
 dretvi kako bi GPU mogao primjenjivati princip prikrivanja latencije, te
 izbjegavati mogučnost grananja unutar dretvi.
 Također treba biti svjestan mane da GPU ne barata dobro sa tipovima podataka
 koji zahtjevaju dvostruku preciznost (64 bita) brojeva sa pomičnim zarezom,
 performanse su značajno lošije nego prilikom rada sa brojevima jednostruke
 preciznosti (32 bita), GPU-ovi zadnje generacije nude jednake performanse
 za oba tipa podataka.
\end_layout

\begin_layout Standard
Još jedna praktična osobina GPU-a je što ih se više može relativno jednostavno
 udružiti, kako već po samom dizajnu jesu paralelni, a ne moraju se brinuti
 oko mnogo drugih podsustava u računalu za koje se CPU brine, npr.
 upravljačkih programa za pristup tvrdim diskovima, računalnoj mreži, periferija
ma i tako dalje.
 Mogučnost uparivanja kartica sa GPU-om je već dulji niz godina dostupna
 kod određenih modela, a recimo 
\emph on
Tesle
\emph default
 i fizički imaju po 4 i više GPU-a na jednoj kartici.
 Za korištenje više CPU-a u jednom računalu je potrebno imati matičnu ploču
 sa više CPU ležišta (od 2 do 8) i mikroprocesore koji to podržavaju, a
 sve to ulazi u poslužiteljsku domenu i znatno diže cijenu, često neproporcional
no dobivenim performansama.
 Naravno ovisno o tipu problema koji se rješava se donosi odluka je li GPU
 ili CPU bolje zadovoljava potrebe i nudi bolje rješenje, u svakom slučaju
 je potrebno imati računalo sa barem jednim CPU-om na kojem će se izvršavati
 operacijski sustav i na taj način biti svojevrstan hipervizor nad GPU-ovima.
 
\end_layout

\begin_layout Standard
Nvidia je u vrijeme pisanja ovog rada najavila novu generaciju svojih grafičkih
 mikroprocesora, nazvanu Fermi.
 Neke od karakteristika i unapređenja koje najavljuju jasno pokazuju da
 
\emph on
Nvidia
\emph default
 sa svojim GPU-ovima više ne cilja samo na prikaz 3D grafike, već i na širu
 primjenu svojih mikroprocesora kroz 
\emph on
GP/GPU
\emph default
, tj.
 
\emph on
CUDA
\emph default
-u i 
\emph on
OpenCL
\emph default
.
 Osim povećanja broja tranzistora (3 milijarde) i broja jezgri (32 
\emph on
CUDA
\emph default
 jezgre po multiprocesoru) tu su još i neka specifičnija poboljšanja poput
 podrške za 64-bitne tipove podataka, povećanje dijeljene (
\emph on
OpenCL
\emph default
 lokalne) memorije, uvođenje L1 i L2 priručne memorije, brža izmjena konteksta
 koji se izvodi, uvođenje dva raspoređivača (engl.
 
\emph on
dispatcher
\emph default
) redoslijeda izvođenja dretvi, sposobnost 
\emph on
Out-of-Order
\emph default
 izvođenja dretvi, podrška za 
\emph on
ECC
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
ECC memorija se koristi u poslužiteljima, a garantira da se prilikom pristupa
 memoriji neće dogoditi pogreška, tj.
 da je dohvaćeni podatak valjan.
\end_layout

\end_inset

 memoriju i mnoga druga poboljšanja.
\end_layout

\begin_layout Standard
Danas CPU i GPU često koegzistiraju u određenim računalima zbog potrebe
 za brzim prikazom 3D grafike, dok se u poslužiteljima isključivo nalaze
 samo CPU-ovi, no i taj trend bi se mogao početi mijenjati, dovoljno je
 napomenuti kako nova superračunala kombiniraju CPU i GPU kakve danas nalazimo
 u osobnim računalima, naravno u daleko većem broju.
 Time GPU postaje svojevrstan matematički koprocesor CPU-u, kao što smo
 prije dvadestak godina imali mogučnost ugradnje dodatnog matematičkog koproceso
ra u računalo, koji se potom kroz vrijeme integrirao u sam mikroprocesor.
\end_layout

\begin_layout Subsection
Cell BE
\end_layout

\begin_layout Standard
Za arhitekturu mikroprocesora 
\emph on
Cell
\emph default
 se može reći da je u neku ruku hibrid CPU-a i GPU-a, također ju nazivaju
 heterogenom višejezgrenom arhitekturom.
 
\emph on
Cell
\emph default
 je predstavljen 2005.
 godine od strane konzorcija 
\emph on
IBM
\emph default
, 
\emph on
Sony
\emph default
 i 
\emph on
Toshiba
\emph default
 koji su ga razvijali za potrebe igrače konzole 
\emph on
Sony Playstation3
\emph default
, za tu svrhu je gotovo pa u potpunosti ispočetka izdizajniran, a ne nadogradnjo
m neke postojeće arhitekture, iz tog razloga je uveo određene novitete u
 arhitekture mikroprocesora.
\end_layout

\begin_layout Standard
Neki od ciljeva su bili proširenje već postojeće 
\emph on
IBM
\emph default
-ove 
\emph on
Power
\emph default
 jezgre s dodatnim akceleratorskim jezgrama, primjena paralelizma visokih
 performansi, velika propusnost prema radnoj memoriji, brz odaziv u realnom
 vremenu zbog osnovne namjene igračoj konzoli, te jednostavnost i fleksibilnost
 u programiranju.
 
\end_layout

\begin_layout Standard
Cell se sastoji od jedne jezgre zvane 
\shape italic
Power Processor Element
\shape default
 (
\emph on
PPE
\emph default
) i osam jezgri zvanih 
\shape italic
Synergistic Processor Elements
\shape default
 (
\emph on
SPE
\emph default
).
 
\emph on
PPE
\emph default
 je jezgra opće namjene temeljene na prijašnjoj 
\emph on
Power
\emph default
 arhitekturi, riječ je o 64-bitnom RISC mikroprocesoru koji radi na 3.2 GHz,
 te je zapravo riječ o dvojezgrenom procesoru.
 Namjena 
\emph on
PPE
\emph default
 jezgre je je izvođenje operacijskog sustava, kontrola nad cijelim mikroprocesor
om i upravljanje nad ostalim 
\emph on
SPE
\emph default
 jezgrama.
 
\emph on
SPE
\emph default
 jezgre su pojednostavljene RISC arhitekture od kojih svaka ima ugrađeni
 
\emph on
DMA
\emph default
 (
\shape italic
\emph on
engl.

\emph default
 direct memory access
\shape default
) kontroler za pristup memoriji, to im omogućava u isto vrijeme izvođenje
 naredbi i dohvaćanje sljedećih potrebnih podataka iz memorij.
 Iz toga razloga 
\emph on
Cell
\emph default
 dostiže velike brzine jer se ne gubi vrijeme potrebno za dohvat novih podataka
 iz memorije.
 
\emph on
PPE
\emph default
 i 
\emph on
SPE
\emph default
 jezgre su povezane unutar mikroprocesora sabirnicom zvanom 
\shape italic
Element Interconnect Bus
\shape default
 (
\emph on
EIB
\emph default
) koja omoguća veliku propusnost između elemenata mikroprocesora, čak preko
 300 GB/s.
 U praksi se učinkovitost 
\emph on
Cella
\emph default
 pokazala za red veličene bolja u odnosu na ostale aktualne mikroprocesore
 u područjima kritpografije, grafike i video procesiranja.
 Naravno pritom treba uzeti u obzir je riječ o 2005./2006.
 godini kada su tek počeli biti dostupni dvojezgreni mikroprocesori.
\end_layout

\begin_layout Standard

\emph on
Cell
\emph default
 mikroprocesor je nadostupniji nabavkom 
\emph on
PlayStationa3
\emph default
 na koji se može instalirati 
\emph on
Yellow Dog
\emph default
 distribucija 
\emph on
GNU/Linuxa
\emph default
 i 
\emph on
IBM
\emph default
-ovo razvojno okruženje (
\emph on
SDK
\emph default
) za 
\emph on
Cell
\emph default
.
 U vrijeme pojave 
\emph on
PlayStationa
\emph default
 je njegova cijena bila relativno mala u odnosu na dobiven mikroprocesor,
 pa su mnogi uočili priliku izgradnje 
\emph on

\begin_inset Quotes eld
\end_inset

uradi sam
\begin_inset Quotes erd
\end_inset


\emph default
 superračunala od nekoliko desetaka ili čak stotina umreženih 
\emph on
PS3
\emph default
-a sa 
\emph on
Cellovima
\emph default
.
 Konkretan primjer je upotreba 200 
\emph on
PS3
\emph default
 konzola 2008.
 godine za računanje kolizija MD5 sažetka koji se koristio prilikom izdavanja
 
\emph on
PKI
\emph default
 certifikata.
 
\emph on
IBM
\emph default
 je 2007.
 godine ponudio na tržištu 
\shape italic
blade
\shape default
 poslužitelje sa 
\emph on
Cell
\emph default
 mikroprocesorima.
 Njihovim korištenje se može na jedan od učinkovitijih načina sastaviti
 izrazito jako računalo, naravno cijenom je rezervirano za viši rang kupaca.
\end_layout

\begin_layout Standard

\emph on
Cell
\emph default
 je ponudio jedan sasvim novi pristup arhitekturi mikroprocesora i nagovijestio
 trend koji tek slijedi, a to spajanje jezgri opće namjene i specijaliziranih
 jezgri u jedan mikroprocesor.
 Posebno je zanimljivo da bi se uskoro mogla očekivati 
\emph on
OpenCL
\emph default
 podrška za 
\emph on
Cell
\emph default
 mikroprocesore, kako je i 
\emph on
IBM
\emph default
 jedan od članova konzoricija koji je radio na 
\emph on
OpenCL
\emph default
 sustavu.
\end_layout

\begin_layout Subsection
Buduće arhitekture
\end_layout

\begin_layout Standard
U kojem smjeru će se razvijati arhitekture i mikroprocesori bazirani na
 njima je relativno teško za procijeniti, no neke osnovne naznake se mogu
 pretpostaviti.
 Danas imamo na raspolaganju mikroprocesore x86_64 arhitekture kompanija
 Intel i 
\emph on
AMD
\emph default
, grafičke mikroprocesore 
\emph on
Nvidie
\emph default
 i 
\emph on
AMD
\emph default
-a odnosno 
\emph on
ATI
\emph default
-ja, a 
\emph on
IBM
\emph default
 ima svoj 
\emph on
Cell
\emph default
 dostupan na užem području.
 
\end_layout

\begin_layout Standard
Prije bilo kakve procjene potrebno je sagledati i trenutnu situaciju podrške
 softvera određenim arhitekturama.
 Danas sva osobna računala, stolna i prijenosna, sadrže CPU arhitekture
 x86, također i gotovo svi poslužitelji, te superračunala.
 Mikroprocesori arhitekture x86 su se još 90' nametnuli osnovna arhitektura
 svakog računala, te se danas na njoj izvode svi operacijski sustavi, 
\emph on
Windows
\emph default
, 
\emph on
GNU/Linux
\emph default
, 
\emph on
*BSD
\emph default
 i 
\emph on
Mac OS X
\emph default
.
 Grafički mikroprocesori nikad nisu bili namijenjeni izvođenju operacijskog
 sustava, a zbog njihove poprilično drugačije arhitekture postojeće operacijske
 sustave bi bilo u praksi gotovo nemoguće modificirati u tom smjeru.
 GPU se oduvijek koristio za dodatnu akceleraciju određenih poslova za koje
 se CPU pokazao presporim.
 Za korištenje potencijala GPU-a je bilo potrebno imati instalirane upravljačke
 programe na operacijskom sustavu.
 Operacijski sustavi otvorenog i slobodnog programskog koda (
\emph on
Open Source
\emph default
, 
\emph on
Free Software
\emph default
) poput 
\emph on
GNU/Linuxa
\emph default
 i inačica 
\emph on
*BSD
\emph default
-a se uz x86 mogu izvoditi i na cijelom nizu drugih arhitektura, poput 
\emph on
ARM
\emph default
-a u mobilnim uređajima, 
\emph on
MIPS
\emph default
-a u ugradbenim uređajima, 
\emph on
PPE
\emph default
 jezgre (
\emph on
Power
\emph default
 arhitektura) u 
\emph on
Cellu
\emph default
, te mnogim drugim.
 Može se zaključiti kako u računalu bilo koje svrhe moramo imati arhitekturu
 CPU-a na kojoj se može izvoditi operacijski sustav, a opcionalno i GPU
 ili neki drugi akceleratorski mikroprocesor u svrhu izvedbe algoritama
 za koje je CPU prespor.
 Time su moguće tri kombinacije mikroprocesora u računalu:
\end_layout

\begin_layout Enumerate
jedan ili više CPU, svaki može biti višejezgreni
\end_layout

\begin_layout Enumerate
jedan ili više CPU, svaki može biti višejezgreni + jedan ili više GPU
\end_layout

\begin_layout Enumerate
mikroprocesor koji je 
\shape italic

\begin_inset Quotes eld
\end_inset

hibrid
\begin_inset Quotes erd
\end_inset


\shape default
 CPU-a i GPU-a: 
\emph on
Cell
\emph default
, 
\emph on
Intel
\emph default
 
\emph on
Larrabee
\emph default
, ...
\end_layout

\begin_layout Standard
Odabir neke od prethodnih kombinacija ovisi o namjeni računala i poslu koji
 će obavljati.
 Kako je već prije opisan problem prenosivosti programskog koda među platformama
, ovo je mjesto gdje 
\emph on
OpenCL
\emph default
 savršeno popunjava prazninu.
 Neovisno o arhitekturi mikroprocesora, tekst programa napisan u 
\emph on
OpenCL
\emph default
 bi trebao detektirati platforme na kojima se nalazi i izvoditi se na njima.
 Je li riječ o zahtjevnim znanstvenim proračunima ili korisničkim aplikacijama
 koje zahtjevaju veću obradu podataka nije odviše bitno, jer će isti tekst
 programa imati mogučnost izvođenja na uobičajenom dvojezgrenom CPU-u kakav
 danas nalazimo u osobnim računalima, poslužitelju sa nekoliko višejezgrenih
 CPU-a ili GPU-u nižeg odnosno višeg cijenovnog ranga.
 Kao trenutne mane 
\emph on
OpenCL
\emph default
-a se mogu navesti trenutni nedostak implementacija za sve platforme i nemogučno
st jednostavnog izvršavanja na više računala istovremeno.
\end_layout

\begin_layout Standard
Trenutno sve upućuje da kroz sljedećeih nekoliko godina možemo očekivati
 mikroprocesore koji će dobro izvoditi poslove opće namjene poput CPU-a,
 ali i posjedovati mogučnost obrade velike količine podataka po SIMD prinicpu.
 Sigurno je da će se realizirati kroz višejezgrenost poput 
\emph on
Cella
\emph default
.
 Tu se javlja pitanje orijentacije kompanija, te tehnologija i vlasničkih
 prava nad patentima.
 Trenutno patentna prava za x86 tehnologiju i njezina proširenja (npr.
 SSE setovi instrukcija) imaju pretežito 
\emph on
Intel
\emph default
 i tek iza njega 
\emph on
AMD
\emph default
, točnije mnoge licence su odlučili dijeliti ili pak međusobno plačati,
 kako bi njihovi mikroprocesori bili međusobno kompatibilni.
 
\end_layout

\begin_layout Standard
U tom pogledu je trenutno 
\emph on
AMD/ATI
\emph default
 u najboljem položaju, jer se 
\emph on
AMD
\emph default
 bavi proizvodnjom x86 mikroprocesora, a 
\emph on
ATI
\emph default
 grafičkih mikroprocesora, što im osigurava posjedovanje tehnologije i znanja
 za dizajn mikroprocesora koji bi mogao izvoditi naredbe x86 arhitekture,
 a opet imati i SIMD karakteristike grafičkih mikroprocesora.
 
\emph on
Intel
\emph default
 je već u tom smjeru najavio sasvim novi mikroprocesor zvan 
\emph on
Larrabee
\emph default
, bio bi baziran na x86 arhitekturi sa velikim brojem jezgri i mogučnošću
 paralelne obrade podataka.
 Zanimljivo je da 
\emph on
IBM
\emph default
 već ima 
\emph on
Cell
\emph default
 koji se poprilično dobro uklapa u prethodni opis, no nije riječ o x86 arhitektu
ri već od 
\emph on
Power
\emph default
 sa 
\emph on
SPE
\emph default
 jezgrama, što onemogučuje znatniji prodor u osobna računala.
 Također se dugo priča kako 
\emph on
Nvidia
\emph default
 planira izdati svoj x86 mikroprocesor, no zbog patentnih prava je to poprilično
 upitno, druga mogučnost je licenciranje 
\emph on
ARM
\emph default
 arhitekture i njena kombinacija sa već postojećim GPU-ovima, no to opet
 nebi omogučilo prodor u domenu centralnih mikroprocesora osobnih računala.
 Može se zaključiti kako je pitanje vremena kada ćemo u osobnim računalima
 imati mikroprocesore koji kombiniraju karakteristike CPU-a i GPU-a, samo
 je pitanje u kojem obliku, osnovni problem je zadržavanje kompatibilnosti
 sa postojećim operacijskim sustavima i aplikacijama.
 Naravno to ne isključuje i dalje postojanje akceleratorskih mikroprocesora
 koji će se opcionalno ugrađivati u računala koja već imaju nekakav centralni
 mikroprocesor.
 Još jedan pokazatelj razvoja u tom smjeru je 
\emph on
Intelova
\emph default
 kupovina udjela u kompaniji
\emph on
 Imagination Technologies
\emph default
 koja proizvodi 3D akceleratorske mikroprocesore za mobilne uređaje.
\end_layout

\begin_layout Standard
Ne treba zanemarivati i činjenicu da je dizajn novog mikroprocesora i njegova
 proizvodnja izuzetno skupo, te si proizvođači ne smiju dozvoljavati prevelike
 pogreške u procjenama tržišta.
 Ako se odmaknemo od osobnih prema računalima specifičnije namjene poput
 nekih poslužitelja i superračunala, zadržavanje x86 arhitekture i ne stvara
 veći problem iz razloga što se i danas za sve zahtjevnije poslove, računala
 i pripadajući softver posebno prilagođavaju, jer nema potrebe za širom
 namjenom, npr.
 
\emph on
Cell
\emph default
 
\emph on
blade
\emph default
 poslužitelji.
\end_layout

\begin_layout Subsubsection
Intel Larrabee
\end_layout

\begin_layout Standard

\emph on
Intel
\emph default
 je najavio mikroprocesor kodnog naziva 
\emph on
Larrabee
\emph default
 koji bi trebao biti višejezgrena kombinacija CPU-a i GPU-a, baziran na
 x86 arhitekturi s mogučnošću izvođenja SIMD operacija.
 Za razliku od procesora 
\emph on
Cell
\emph default
 sve jezgre bi mu bile istovjetne, a broj bi po najavama bio oko 32.
 Kako se sastoji od x86 jezgri sa određenim proširenjima, teoretski bi trebao
 biti sposoban izvoditi tekst programa koji se danas izvodi na 
\emph on
intelovim
\emph default
 mikroprocesorima.
 
\emph on
Intelove
\emph default
 najave i izvešća su mnogo varirala, po prvim najavama je trebao biti na
 tržištu 2010.
 godine namijenjen svim potrošaćima, dok zadnja spominju njegovu primjenu
 samo u istraživačke i razvojne svrhe poput računarstva visokih performansi.
 U svakom slučaju, bez obzira na vrijeme njegovog pojavljivanja, 
\emph on
Intel
\emph default
 je jasno nagovjestio nove tipove mikroprocesora koji bi objedinili karakteristi
ke CPU-a i GPU-a, ali i pokazao kako drastična promjena trenutne arhitekture
 nije odviše jednostavna, bilo u tehničkom pogledu ili pitanju kompatibilnosti
 sa postojećim softverom.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Ispitivanje i usporedba performansi OpenCL-a
\end_layout

\begin_layout Standard
Za ocjenu performansi su izvedeni primjeri u 
\emph on
OpenCL
\emph default
-u na više platformi, te još u tehnologijama 
\emph on
MPI
\emph default
 i 
\emph on
OpenMP
\emph default
 kako bi se dobili okvirni omjeri njihovih performansi.
 Odmah treba uzeti u obzir činjenicu kako primjeri u različitim tehnologijama
 ne mogu biti izvedeni u istim uvjetima iz razloga što se djelomično izvode
 na različitim platformama, implementacijama i operacijskim sustavima.
 Cilj ispitivanja je upoznavanje sa samim tehnologijama, dobivanje okvirnih
 rezultata, te što je najbitnije omjera među rezultatima kako bi se mogao
 izvuči zaključak kako koja tehnologija i platforma stoji u odnosu na drugu.
 Također je zanimljivo vidjeti kako se koja tehnologija i tip mikroprocesora
 nosi sa porastom dimenzija problema i njegovom paralelizacijom.
\end_layout

\begin_layout Standard
Glavni primjer je množenje matrica različitih veličina i tipova podataka,
 odbran zbog jednostavnosti, relativno lagane paralelizacije u svim tehnologijam
a i njegove sličnosti sa stvarnim zahtjevima u područjima znanstvenih istraživan
ja i procesiranja večih količina podataka.
 Ispitivanja su provedena za kvadratne matrice veličina
\begin_inset Foot
status open

\begin_layout Plain Layout
U tekstu se pod veličinom matrica misli na broj elemenata po dimenziji kvadratne
 matrice, a ne na ukupan broj elemenata matrice.
 
\end_layout

\end_inset

 256, 512, 1024, 1536 i 2048, te cjelobrojne tipove podataka (
\shape italic
\emph on
engl.

\emph default
 integer
\shape default
), sa pomičnim zarezom (
\shape italic
\emph on
engl.

\emph default
 float
\shape default
) i pomičnim zarezom dvostruke preciznosti (
\shape italic
\emph on
engl.

\emph default
 double
\shape default
).
\end_layout

\begin_layout Standard
Primjeri u 
\emph on
OpenCL
\emph default
-u se izvode na platformama GPU i CPU, dok se 
\emph on
MPI
\emph default
 i 
\emph on
OpenMP
\emph default
 izvode samo na CPU-ovima.
 Na temelju tih rezultata se jasno može razlučiti razlika u namjeni pojedine
 platforme i pripadajuće arhitekture.
 Primjeri za 
\emph on
OpenCL
\emph default
 su postupno optimizirani kako bi se uočila razlika dobivenih rezultata
 kroz primjenu optimizacija koje proizvođači preporučaju, poput načina pristupa
 memoriji i raspodjeli problema.
 
\end_layout

\begin_layout Standard
Za provedbu ispitivanja su bile dostupne sljedeće platforme:
\end_layout

\begin_layout Enumerate

\series bold
Thinkpad T61p
\series default

\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="11cm">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPU:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Intel Core 2 Duo T7300, 2GHz, 4MB cache, 4GB RAM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MPI, OMP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nvidia Quadro FX570m, 256MB, 475Mhz
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OpenCL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OS:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GNU/Linux Debian, 64-bit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Mac Mini
\series default

\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="11cm">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPU:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Intel Core 2 Duo P7350, 2GHz, 4MB cache, 1.5GB RAM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OpenCL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nvidia GeForce 9400, 256MB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OpenCL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OS:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mac OS X Snow Leopard Server
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Marvin
\series default

\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="11cm">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPU:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2x Intel Xeon E5504 QuadCore, 2GHz, 4MB cache, 8GB RAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MPI, OMP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OS:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GNU/Linux Debian, 64-bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
OpenMP
\end_layout

\begin_layout Standard

\emph on
OpenMP
\emph default
 je zanimljiv za usporedbu sa 
\emph on
OpenCL
\emph default
-om na arhitekturi CPU-a jer također paralelizira algoritam pokretanjem
 više dretvi i svi mikroprocesori imaju pristup zajedničkoj radnoj memoriji.
 Tako se mogu relativno pouzdano usporediti performanse ovih alata na istom
 centralnom mikroprocesoru.
\end_layout

\begin_layout Standard
Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenMP,-različiti-rangovi"

\end_inset

 prikazuje trajanje množenja matrica u jednodretvenom 
\emph on
C
\emph default
 tekstu programa i višedretvenom kodu paraleliziranom kroz 
\emph on
OpenMP
\emph default
.
 Očekivano je višedretveni kod brži jer se izvodi na osam jezgri, spram
 jednodretvenog koji se može izvoditi samo na jednoj jezgri.
 Isto tako je očekivan rezultat da višedretvena verzija nije osam puta brža
 od jednodretvene, što bi bio idealan slučaj, već se ubrzanje sa porastom
 mikroprocesora odnosno jezgri usporava zbog troškova sinkronizacije.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/openmp-c.eps
	width 10cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenMP,-različiti-rangovi"

\end_inset


\emph on
OpenMP
\emph default
, različite veličine matrica na Marvinu
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Centralni mikroprocesori moraju biti posebne serije koja je namijenjena
 višeprocesorskom radu, najčešće je riječ o serijama namijenjenim za ugradnju
 u poslužitelje.
 Jedna od bitnijih odlika im je ugrađena logika za sinkronizaciju, jer dijele
 istu radnu memoriju (
\emph on
RAM
\emph default
) računala.
 Najčešće se serije CPU-a namijenjenih višeprocesorskom radu dijele na one
 koje mogu raditi do dva zajedno, te one koje mogu do osam zajedno, ali
 su one već značajno skuplje.
\end_layout

\begin_layout Standard
Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenMP,-različiti-tipovi"

\end_inset

 prikazuje razliku trajanja primjera ovisno o tipu podataka.
 Očekivano su cjelobrojni i elementi sa pomičnim zarezom postigli slične
 rezultate, dok je primjer sa tipom dvostruke preciznosti trajao nešto dulje.
 Razlog je duljina tipa podataka: dvostruka preciznost je duljine osam okteta,
 dok su druga dva tipa duljine četiri okteta.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/openmp-datatypes.eps
	width 10cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenMP,-različiti-tipovi"

\end_inset


\emph on
OpenMP
\emph default
, različiti tipovi podataka na Marvinu
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Uočena je zanimljivost prilikom ispitivanja.
 
\emph on
OpenMP
\emph default
 je zapravo proširenje programskog prevodioca, točnije skup predprocesorskih
 naredbi pomoću kojih zatim prevodilac paralelizira tekst programa, tako
 da brzina izvršnog programa uvelike ovisi o kvaliteti samog prevodioca.
 U ovom slučaju je korišten 
\emph on
GCC 4.4.2
\emph default
 (
\emph on
GNU C Compiler
\emph default
) koji je u početku generirao višedretveni program koji se izvodio značajno
 dulje nego jednodretveni program.
 Rješenje problema je bilo eksplicitno označavanje varijabli privatnima
 (engl.
 
\emph on
autoscoping
\emph default
) jer prevodilac očigledno to ne radi sam, te alokacija matrice kroz pokazivač
 na pokazivače svakog reda.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

#pragma omp parallel for private(i, j, k, sum)  
\end_layout

\begin_layout Plain Layout

for (i = 0; i < rank; ++i)
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pretraživanjem Interneta je utvrđeno da su i neki drugi korisnici imali
 istih problema sa 
\emph on
GCC
\emph default
-om, dok im drugi programski prevodioci nisu stvarali slične probleme.
 Ovaj primjer samo dokazuje da većina optimizacija leži u dobro napisanom
 programskom kodu i kvalitetnom prevodiocu.
\end_layout

\begin_layout Subsection
MPI
\end_layout

\begin_layout Standard
Sustav 
\emph on
MPI
\emph default
 za razliku od 
\emph on
OpenMP
\emph default
-a paralelizira algoritme pokretanjem procesa, a ne dretvi, te omogućava
 komunikaciju porukama između više računala.
 Paralelizacija je kompliciranija za programera jer se mora brinuti oko
 razmjene poslova i podataka porukama te za sinkronizaciju, dok se kod 
\emph on
OpenMP
\emph default
-a za paralelizaciju većinom brine prevodilac.
\end_layout

\begin_layout Standard
Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MPI,-različiti-rangovi"

\end_inset

 prikazuje trajanje testova ovisno o broju pokrenutih procesa odnosno korištenih
 jezgri CPU-a.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/mpi-cores.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MPI,-različiti-rangovi"

\end_inset


\emph on
MPI
\emph default
, različite veličine matrica i brojevi procesa na Marvinu
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Očekivano je veći broj jezgri završio primjer u kraćem vremenu, a isto tako
 očekivano sa porastom jezgri se vrijeme nije linearno smanjivalo zbog troškova
 komunikacije i sinkronizacije.
 Prikazani rezultati se odnose na podatke sa pomičnim zarezom, dok su oni
 dvostruke preciznosti također ostvarili nešto dulja trajanja kao kod 
\emph on
OpenMP
\emph default
-a.
 U trajanje nije uračunato vrijeme potrebno za kopiranje matrica svakom
 procesu, već samo računanje i prikupljanje rezultata od svakog procesa.
 Razlog je taj što se u navedenom primjeru kopiraju cijele matrice svakom
 procesu, dok bi u optimiziranijem slučaju to bili samo dijelovi matrica
 koji su potrebni procesu za izračun.
\end_layout

\begin_layout Standard
Može se zaključiti kako povećanje broja CPU-ova, tj.
 jezgri, u računalu poboljšava performanse, ali samo do neke mjere, tj.
 rast performansi odgovara logaritamskoj funkciji, dok cijena nažalost raste
 eksponencijalno.
 Iz tog razloga je danas najčešća gornja granica od osam CPU-a u jednom
 računalu.
 Navedeno ograničenje se odnosi na sve tehnologije koje barataju sa CPU-ovima,
 uključujući i 
\emph on
OpenCL
\emph default
 dok se izvodi na CPU.
 Sljedeći korak je povećanje broja računala, čime naravno raste kompleksnost
 algoritama u smislu raspodjele poslova i podataka.
 Bitno je, bez obzira na korišteni sustav, voditi računa o optimizaciji
 programskog koda, poput izbjegavanja uskih grla u sustavu, učinkovite raspodjel
e poslova, optimizacije raspodjele podataka i pristupa memoriji.
\end_layout

\begin_layout Standard
Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenMP---MPI,"

\end_inset

 prikazuje usporedbu trajanja izvođenja primjera između 
\emph on
OpenMP
\emph default
 programa sa više dretvi i 
\emph on
MPI
\emph default
 programa sa osam procesa; očekivano je 
\emph on
OpenMP
\emph default
 nešto brži iz razloga svoje jednostavnosti u odnosu na 
\emph on
MPI
\emph default
.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/mpi-openmp.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenMP---MPI,"

\end_inset


\emph on
OpenMP
\emph default
 - 
\emph on
MPI
\emph default
, Marvin
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
OpenCL
\end_layout

\begin_layout Standard
Za 
\emph on
OpenCL
\emph default
 primjere su bile dostupne dvije platforme, prijenosno računalo 
\emph on
Thinkpad t61p
\emph default
 sa 
\emph on
Nvidia Quadro FX570m
\emph default
 grafičkim mikroprocesorom i 
\emph on
Mac Mini
\emph default
 sa 
\emph on
Nvidia GeForce 9400
\emph default
 i 
\emph on
Intel Core 2 Duo
\emph default
 mikroprocesorom.
 Cilj je usporediti rezultate izvođenja primjera množenja matrica napisanih
 u 
\emph on
OpenCL
\emph default
-u sa dobivenim rezultatima u drugim sustavima, te dati okviran omjer postignuti
h performansi među različitim arhitekturama, CPU i GPU.
 
\emph on
OpenCL
\emph default
 primjeri uključuju uspoređivanje performansi sa različitim veličinama matrica,
 globalnog i lokalnog indeksnog prostora, te različitih tipova podataka.
\end_layout

\begin_layout Standard
Primjeri su izvedeni korištenjem 
\emph on
python
\emph default
 sučelja za 
\emph on
OpenCL
\emph default
 naziva 
\emph on
pyOpenCL
\emph default
.
 Razlog je lakše postavljanje okoline za izvođenje programskih jezgri, koje
 su opet napisane u 
\emph on
OpenCL C
\emph default
-u.
 Program 
\emph on
opencl-mm.py
\emph default
 služi za pokretanje primjera, a kroz komandnu liniju mu se mogu postaviti
 parametri poput dimenzija matrica i podmatrica, tipa podataka i ispisa
 matrica u svrhu provjere rezultata.
 U sustavu 
\emph on
OpenCL
\emph default
 veličine globalnog i lokalnog indeksnog prostora odgovaraju dimenzijama
 matrica i podmatrica.
 Sintaksa za pokretanje je sljedeća:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

veljko:~/diplomski/src/opencl-mm$ ./opencl-mm.py -h 
\end_layout

\begin_layout Plain Layout

Parameters:
\end_layout

\begin_layout Plain Layout

  [-d | --dimensions] MxNxP : Matrices dimensions, [m n] * [n p]
\end_layout

\begin_layout Plain Layout

  [-b | --block] N          : Block size, N x N
\end_layout

\begin_layout Plain Layout

  [-t | --datatype] type    : DataType [int|float|double] 
\end_layout

\begin_layout Plain Layout

                              (default float)
\end_layout

\begin_layout Plain Layout

  [-v | --verbose]          : Prints matrices for checking purpose
\end_layout

\begin_layout Plain Layout

  [-h | --help]             : Shows this help 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dimenzije se označavaju sintaksom 
\emph on
MxNxP
\emph default
, gdje je 
\emph on
M
\emph default
 broj redaka matrice 
\emph on
A
\emph default
, 
\emph on
N
\emph default
 stupaca matrice 
\emph on
A
\emph default
 i redaka matrice 
\emph on
B
\emph default
, te 
\emph on
P
\emph default
 broj stupaca matrice 
\emph on
B
\emph default
.
 Nisu sve veličine bloka dozvoljene, već dimenzije moraju biti višekratnik
 veličine bloka.
 U primjerima su korišteni blokovi veličine 1, 4, 8 i 16.
 Tipovi podataka mogu biti cjelobrojni (4 okteta), sa pomičnim zarezom (4
 okteta) i dvostruke preciznosti (8 okteta), bitno je obratiti pažnju da
 
\shape italic
--datatype
\shape default
 parametar samo postavlja okolinu 
\emph on
OpenCL
\emph default
-a za željeni tip podataka, dok se u programskoj jezgri zasebno mora pripaziti
 kakav se tip podataka definira.
\end_layout

\begin_layout Standard
Primjer otkrivanja dostupnih 
\emph on
OpenCL
\emph default
 platformi na 
\emph on
Apple Mac OS X
\emph default
 operacijskom sustavu, te ispis podrobnijih podataka:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

Platform name: Apple 
\end_layout

\begin_layout Plain Layout

Platform profile: FULL_PROFILE 
\end_layout

\begin_layout Plain Layout

Platform vendor: Apple 
\end_layout

\begin_layout Plain Layout

Platform version: OpenCL 1.0 (Oct 16 2009 04:12:08)
\end_layout

\begin_layout Plain Layout

------------------------------------ 
\end_layout

\begin_layout Plain Layout

Device name: GeForce 9400 
\end_layout

\begin_layout Plain Layout

Device type: GPU 
\end_layout

\begin_layout Plain Layout

Device memory:  256 MB 
\end_layout

\begin_layout Plain Layout

Device max clock speed: 1100 MHz 
\end_layout

\begin_layout Plain Layout

Device compute units: 2 
\end_layout

\begin_layout Plain Layout

------------------------------------ 
\end_layout

\begin_layout Plain Layout

Device name: Intel(R) Core(TM)2 Duo CPU P7350  @ 2.00GHz 
\end_layout

\begin_layout Plain Layout

Device type: CPU 
\end_layout

\begin_layout Plain Layout

Device memory:  1536 MB 
\end_layout

\begin_layout Plain Layout

Device max clock speed: 2000 MHz 
\end_layout

\begin_layout Plain Layout

Device compute units: 2 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Za potrebe ispitivanja su napisane tri programske jezgre koje se razlikuju
 po korištenju indeksnog prostora i globalne odnosno lokalne memorije.
 Tako su prikazana dva osnovna koncepta pisanja 
\emph on
OpenCL
\emph default
 programskih jezgri, granulacija problema kroz indeksni prostor i odnos
 brzine pristupa globalnoj i lokalnoj memoriji.
\end_layout

\begin_layout Subsubsection
Primjer: zbrajanje matrica, programska jezgra 1
\end_layout

\begin_layout Standard
Prvi primjer prikazuje najjednostavniji način paralelizacije algoritama
 koristeći globalne indekse.
 Na domaćinu se stvaraju memorijski međuspremnici za matrice, koji se zatim
 kopiraju u memoriju uređaja, a također se proslijede i dimenzije matrica
 kroz argumente 
\emph on
m
\emph default
, 
\emph on
n
\emph default
 i 
\emph on
p
\emph default
.
 Za svaki element indeksnog prostora koji odgovara veličini matrice 
\emph on
C
\emph default
, u koju se sprema rezultat, pokreće se po jedna programska jezgra, svaka
 sa svojim globalnim indeksom.
 Konačno se kroz petlju obavlja množenje odgovarajućeg retka matrice 
\emph on
A
\emph default
 sa stupcem matrice 
\emph on
B
\emph default
, te se rezultat sprema u element matrice 
\emph on
C
\emph default
 određen prije dobivenim indeksima.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

__kernel void matrix_mul(const __global float* A,
\end_layout

\begin_layout Plain Layout

                         const __global float* B,
\end_layout

\begin_layout Plain Layout

                         __global float* C,
\end_layout

\begin_layout Plain Layout

                         uint m, uint n, uint p) 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

	// određivanje retka i stupca u indeksnom prostoru
\end_layout

\begin_layout Plain Layout

    uint row = get_global_id(0);   
\end_layout

\begin_layout Plain Layout

    uint col = get_global_id(1);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // množenje elemenata matrica, C = A * B
\end_layout

\begin_layout Plain Layout

    C[row * p + col] = 0;
\end_layout

\begin_layout Plain Layout

    for (uint k = 0; k < n; ++k)     
\end_layout

\begin_layout Plain Layout

        C[row * p + col] += A[row * n + k] * B[k * p + col]; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Primjer: zbrajanje matrica, programska jezgra 2
\end_layout

\begin_layout Standard
Razlika u odnosu na prvi primjer je što se ilustrira korištenje radnih grupa
 i lokalnih indeksa unutar njih.
 Drugi primjer u pogledu performansi nema značajnu prednost u odnosu na
 prvi, već više služi kao primjer granulacije problema kroz grupe.
 Zanimljivo je kako je na korisniku da sam odredi globalni i lokalni indeksni
 prostor, te kasnije u programskim jezgrama iskoristi tu dodatnu granulaciju
 za učinkovitije rješavanje problema.
 Na temelju indeksa radne grupe i lokalnog indeksa, može se za svaku programsku
 jezgru odrediti njezin globalni indeks.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

__kernel void matrix_mul(const __global float* A,
\end_layout

\begin_layout Plain Layout

                         const __global float* B,
\end_layout

\begin_layout Plain Layout

                         __global float* C,
\end_layout

\begin_layout Plain Layout

                         uint m, uint n, uint p)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // određivanje veličine bloka   
\end_layout

\begin_layout Plain Layout

    uint blockSize = get_local_size(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // određivanje indeksa radne grupe
\end_layout

\begin_layout Plain Layout

    uint row = get_group_id(0);
\end_layout

\begin_layout Plain Layout

    uint col = get_group_id(1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // određivanje lokalnih indeksa u grupi
\end_layout

\begin_layout Plain Layout

    uint x = get_local_id(0);
\end_layout

\begin_layout Plain Layout

    uint y = get_local_id(1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // određivanje indeksa u matrici kroz grupe i lokalne indekse
\end_layout

\begin_layout Plain Layout

    uint pos_x = (row * blockSize + x) * p;   
\end_layout

\begin_layout Plain Layout

    uint pos_y = col * blockSize + y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // množenje elemenata matrica, C = A * B
\end_layout

\begin_layout Plain Layout

    C[pos_x  + pos_y] = 0;
\end_layout

\begin_layout Plain Layout

    for( uint k = 0; k < n; ++k)     
\end_layout

\begin_layout Plain Layout

        C[pos_x + pos_y] += A[pos_x + k] * B[k * p + pos_y]; }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Primjer: zbrajanje matrica, programska jezgra 3
\end_layout

\begin_layout Standard
Treći primjer za razliku od prethodna dva koristi i lokalnu memoriju, te
 dijelove matrica kopira iz globalne u lokalnu memoriju.
 Kako se svaki element matrica koristi više puta, svaki pristup globalnoj
 memoriji oduzima značajno vrijeme.
 Kopiranjem blokova elemenata u znatno bržu lokalnu memoriju mogu se povećati
 performanse i za jedan red veličine.
 Razlika u deklaraciji funkcije programske jezgre je što se među argumentima
 nalazi i lokalna memorija, kroz te argumente se ništa ne proslijeđuje već
 služe samo za alokaciju memorije.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

__kernel void matrix_mul(const __global float* A,
\end_layout

\begin_layout Plain Layout

                         const __global float* B,
\end_layout

\begin_layout Plain Layout

                         __global float* C,
\end_layout

\begin_layout Plain Layout

                         uint m, uint n, uint p,
\end_layout

\begin_layout Plain Layout

                         __local float* subA,
\end_layout

\begin_layout Plain Layout

                         __local float* subB)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // broj radnih grupa i njihove dimenzije  
\end_layout

\begin_layout Plain Layout

    uint numGroups = get_num_groups(0);   
\end_layout

\begin_layout Plain Layout

    uint blockSize = get_local_size(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // indeksi radne grupe  (2 dimenzije)
\end_layout

\begin_layout Plain Layout

    uint row = get_group_id(0);   
\end_layout

\begin_layout Plain Layout

    uint col = get_group_id(1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // lokalni indeksi jezgre u radnoj grupi  
\end_layout

\begin_layout Plain Layout

    uint x = get_local_id(0);   
\end_layout

\begin_layout Plain Layout

    uint y = get_local_id(1);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    float subC = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // iteracija kroz sve blokove matrica A i B potrebnih za računanje 
  
\end_layout

\begin_layout Plain Layout

    for(int blockA = row * blockSize * n , blockB = col * blockSize;
\end_layout

\begin_layout Plain Layout

        blockA <= row * blockSize * n + numGroups * blockSize - 1;
\end_layout

\begin_layout Plain Layout

        blockA += blockSize, blockB += blockSize * p)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // kopiranje elemenata matrica A i B u podmatrice u lokalnoj mem.
\end_layout

\begin_layout Plain Layout

        // svaka radna jedinica kopira po jedan element
\end_layout

\begin_layout Plain Layout

        subA[x * blockSize + y] = A[blockA + x * n + y];
\end_layout

\begin_layout Plain Layout

        subB[x * blockSize + y] = B[blockB + x * p + y];
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

        // čekanje da sve radne jednice završe kopiranje
\end_layout

\begin_layout Plain Layout

        barrier(CLK_LOCAL_MEM_FENCE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // množenje elemenata podmatrica A i B
\end_layout

\begin_layout Plain Layout

        for(int k = 0; k < blockSize; ++k)
\end_layout

\begin_layout Plain Layout

            subC += subA[x * blockSize + k] * subB[k * blockSize + y];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       // opet čekanje da sve radne jedinice završe računanje
\end_layout

\begin_layout Plain Layout

        barrier(CLK_LOCAL_MEM_FENCE);     
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // postavljanje rezultata u globalnu matricu C 
\end_layout

\begin_layout Plain Layout

    C[get_global_id(0) * get_global_size(0) + get_global_id(1)] = subC;
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL-Test-3,"

\end_inset

 ilustrira raspodijelu matrica po blokovima.
 Tamniji blokovi matrica 
\emph on
A
\emph default
 i 
\emph on
B
\emph default
 se kopiraju u lokalnu memoriju prilikom računanja elemenata označenog bloka
 matrice 
\emph on
C
\emph default
.
 Svi blokovi odnosno radne grupe su istih dimenzija, tj.
 kvadratnih su veličina.
 Algoritam kopira blok (podmatricu) matrica 
\emph on
A
\emph default
 i 
\emph on
B
\emph default
 u lokalnu memoriju, izračuna rezultat tih podbloka, te ponovi isto za sljedeće.
 Tako se izbjegava višestruko pristupanje istim podacima u globalnoj memoriji,
 već se potrebni podaci kopiraju u lokalnu memoriju, te im se zatim višestruko
 pristupa.
 
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/mm.png
	lyxscale 50
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL-Test-3,"

\end_inset


\emph on
OpenCL
\emph default
 Primjer 3, podjela problema na blokove
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Rezultati primjera zbrajanja matrica
\end_layout

\begin_layout Standard
Slike 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka-4"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka-8"

\end_inset

 i 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka-16"

\end_inset

 prikazuju rezultate koje su ostvarili primjeri programskih jezgri 1, 2
 i 3, ovisno o veličini bloka, redom 1, 4, 8 i 16, te veličini matrica,
 korišten je tip podataka sa pomičnim zarezom.
 Primjeri su izvedeni na GPU platformi 
\emph on
Nvidia FX570m
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/opencl-bs-1.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL,-veličina-bloka"

\end_inset


\emph on
OpenCL
\emph default
, veličina bloka 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/opencl-bs-4.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL,-veličina-bloka-4"

\end_inset


\emph on
OpenCL
\emph default
, veličina bloka 4
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/opencl-bs-8.eps
	width 10cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL,-veličina-bloka-8"

\end_inset


\emph on
OpenCL
\emph default
, veličina bloka 8
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/opencl-bs-16.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL,-veličina-bloka-16"

\end_inset


\emph on
OpenCL
\emph default
, veličina bloka 16
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Svi grafovi pokazaju jednako trajanje izvođenja primjera 1 i 2, bez obzira
 na veličinu bloka i tip podataka.
 Razlog je što jedan u odnosu na drugi nema nikakvu prednost što se tiče
 optimalnosti programskog koda, već se prvi oslanja na globalne indekse,
 dok se drugi oslanja na indekse grupa i lokalne indekse.
 
\end_layout

\begin_layout Standard
Na slici 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka"

\end_inset

 prikazano je trajanje izračuna u slučaju kada je veličina bloka jednaka
 jedan, u kojem slučaju test 3 postiže najlošije rezlutate.
 Razlog je što se u ovom primjeru sadržaj blokova kopira u lokalnu memoriju,
 a kako je veličina bloka jednaka jedan, efektivno se svaki element matrica
 kopira zasebno u lokalnu memoriju.
 Kopiranjem samo jednog elementa se ne postiže nikakvo ubrzanje, već se
 samo nepotrebno troši vrijeme na kopiranje elementa iz globalne u lokalnu
 memoriju, te se čeka sinkronizacija dretvi.
\end_layout

\begin_layout Standard
Slike 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka-4"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka-8"

\end_inset

 i 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka-16"

\end_inset

 prikazuju rezultate za veličine grupa 4, 8 i 16.
 U tim slučajevima su se svi testovi pokazali bržima, a test 3 značajno
 nadmašuje ostale testove, čak i za red veličine.
 Razlog je što jedan multiprocesor u GPU-u izvodi odjednom skupinu dretvi,
 te na taj način prikriva latenciju pristupa memoriji, što utječe na sve
 testove.
 Primjer 3 je značajno brži jer iz globalne memorije kopira cijeli blok
 podataka u lokalnu memoriju, a taj blok odgovara kvadratu veličine bloka.
 Tako više dretvi više puta pristupa lokalnoj memoriji, a samo jednom globalnoj
 prilikom kopiranja podataka.
 Za konkretan slučaj se veličina bloka od 8 pokazala najučinkovitijom.
 Sami proizvođači GPU-ova predlažu da na veličinu bloka, točnije lokalnu
 veličinu indeksnog prostora, treba obratiti pažnju iz razloga što sam sustav
 ne može pouzdano odrediti njenu optimalnu veličinu, već je bolje da sam
 programer procijeni i isproba koja postiže najbolje rezultate.
\end_layout

\begin_layout Standard
Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-usporedba-tipova"

\end_inset

 prikazuje odnos performansi za cjelobrojne tipove podataka i one sa pomičnim
 zarezom.
 Uzeta je veličina bloka 8 jer se pokazala najučinkovitijom.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/opencl-datatype.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL,-usporedba-tipova"

\end_inset


\emph on
OpenCL
\emph default
, usporedba tipova podataka
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Očekivano je kao i kod CPU-a test sa cjelobrojnim podacima trajao otprilike
 jednako kao i onaj sa pomičnim zarezom.
 Primjer sa dvostrukom preciznošću nije bilo moguće izvesti jer je sustav
 tražio navođenje predprocesorske naredbe u programskoj jezgri kako bi uključio
 mogučnost rada sa 64-bitnim podacima, no i nakon toga je tvrdio da nema
 mogućnosti za to.
 Razlog je što je ta podrška kod 
\emph on
Nvidie
\emph default
 uključena tek u grafičkim mikroprocesorima zadnje generacije.
 Kako je osnovna namjena GPU-a prikaz grafike za koju nije bitna dvostruka
 preciznost, ta mogućnost nije bila ni potrebna.
 U novijim mikroprocesorima je dodana i ta mogućnost upravo iz razloga znanstven
ih izračuna koji se mogu izvoditi na GPU-u, a često zahtjevaju dvostruku
 preciznost odnosno rad sa podacima duljine osam okteta.
\end_layout

\begin_layout Subsubsection
Primjer: simulacija međudjelovanja čestica
\end_layout

\begin_layout Standard
Uz primjer množenja matrica, koji je napisan za više različitih sustava,
 za potrebe ispitivanja 
\emph on
OpenCL
\emph default
-a je napisan i primjer simulacije međudjelovanja čestica (engl.
 
\emph on
N-body simulation
\emph default
).
 Radi se o učestalom primjeru simuliranja fizikalnih pojava, poput međusobnog
 djelovanja velikog broja čestica u prostoru.
 Riječ je o računalno poprilično zahtjevnom poslu jer je odlika dobre simulacije
 korištenje što većeg broja čestica s pripadajućim parametrima, te uzimanje
 što manjeg vremenskog perioda u simulaciji, što rezultira velikim brojem
 iteracija.
 Za ilustraciju je dovoljno zamisliti simulaciju gibanja fluida, poput valovitog
 mora pod utjecajem vremenskih (tlak, vjetar) i fizikalnih (privlačne sile
 čestica) prilika.
 
\end_layout

\begin_layout Standard
Napravljeni primjer za ove potrebe nije odviše kompleksan, već se u izračun
 uzimaju samo trenutne pozicije čestica u prostoru, te njihova masa i trenutna
 brzina.
 Svakom iteracijom se za svaku česticu računaju privlačne (gravitacijske)
 sile kojom sve druge čestice djeluju na nju, te se na temelju toga izračunava
 nova pozicija u prostoru.
 Početno stanje sustava se postavlja slučajnim odabirom početne pozicije
 svake čestice i njene mase, a početne brzine su jednake nuli.
\end_layout

\begin_layout Standard
Aplikacija je također napisana u 
\emph on
pyOpenCL-
\emph default
u i kroz parametre joj se može određivati broj čestica koji odgovara globalnom
 indeksnom prostoru, zatim veličina bloka/grupe koji odgovara lokalnom indeksnom
 prostoru, te ukupan broj iteracija u simulaciji.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

veljko:~/diplomski/src/opencl-nbody $ ./opencl-nbody.py -h
\end_layout

\begin_layout Plain Layout

Parameters:
\end_layout

\begin_layout Plain Layout

  [-n | --size] N   : Number of particles (default: 1024) (power of 2)
\end_layout

\begin_layout Plain Layout

  [-b | --block] N  : Block size (default: 4)
\end_layout

\begin_layout Plain Layout

  [-i | --iters] N  : Number of iterations (default: 128)
\end_layout

\begin_layout Plain Layout

  [-h | --help]     : Shows this help
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Razlika u odnosu na primjer množenja matrica je što se koristi jednodimenzionaln
i indeksni prostor.
 Za pohranu trenutne pozicije i mase se koristi vektorski tip podataka
\begin_inset Foot
status open

\begin_layout Plain Layout
Vektorski tipovi podataka su odlika GPU-a, ali i novijih CPU-a sa SSE3 setom
 instrukcija.
\end_layout

\end_inset

 
\emph on
float4
\emph default
.
 Vektorski tipovi podataka se kod prikaza grafike koriste za spremanje pozicija
 u prostoru, a mogu se zamisliti kao uobičajen niz podataka, ali kraće i
 unaprijed određene duljine (2, 4, 8 ili 16).
 U ovom primjeru se koristi tip 
\emph on
float4
\emph default
 koji se sastoji od četiri vrijednosti sa pomičnim zarezom, prve tri se
 koriste za poziciju u prostoru, a četvrta za masu čestice.
 Isti tip se koristi i za brzinu čestica, ali se kod njega četvrti element
 zanemaruje.
 Slijedi zakomentirani ispis teksta programske jezgre:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

__kernel void nbody_simulation(int iters, float _dt, float limit,
\end_layout

\begin_layout Plain Layout

                               __global float4* _position,
\end_layout

\begin_layout Plain Layout

                               __global float4* _velocity,
\end_layout

\begin_layout Plain Layout

                               __local float4* block)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  // dohvaćanje lokalne veličine i broja grupa
\end_layout

\begin_layout Plain Layout

  int l_size = get_local_size(0);
\end_layout

\begin_layout Plain Layout

  int n_groups = get_num_groups(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // dohvaćanje globalnog i lokalnog indeksa dretve
\end_layout

\begin_layout Plain Layout

  int g_tid = get_global_id(0);
\end_layout

\begin_layout Plain Layout

  int l_tid = get_local_id(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // definiranje vremenskog intervala za simulaciju
\end_layout

\begin_layout Plain Layout

  // (primjer korištenja vektorskog tipa podataka)
\end_layout

\begin_layout Plain Layout

  const float4 dt = (float4)(_dt, _dt, _dt, 0.0f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // željeni broj iteracija za simulaciju
\end_layout

\begin_layout Plain Layout

  for (int i=0; i < iters; i++)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    // početna pozicija, brzina i akceleracija
\end_layout

\begin_layout Plain Layout

    float4 position = _position[g_tid];
\end_layout

\begin_layout Plain Layout

    float4 velocity = _velocity[g_tid];
\end_layout

\begin_layout Plain Layout

    float4 a = (float4)(0.0f, 0.0f, 0.0f, 0.0f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // prolazak kroz sve grupe
\end_layout

\begin_layout Plain Layout

    for (int gid=0; gid < n_groups; ++gid)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // svaka dretva kopira po jedan element iz
\end_layout

\begin_layout Plain Layout

      // globalne u lokalnu memoriju, sinkronizacija
\end_layout

\begin_layout Plain Layout

      block[l_tid] = _position[gid * l_size + l_tid];
\end_layout

\begin_layout Plain Layout

      barrier(CLK_LOCAL_MEM_FENCE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // prolazak kroz sve čestice u grupi
\end_layout

\begin_layout Plain Layout

      for (int k=0; k<l_size; ++k)
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        // izračun udaljenosti između čestica
\end_layout

\begin_layout Plain Layout

        float4 d = block[k] - position;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // izračun akceleracije čestice
\end_layout

\begin_layout Plain Layout

        // primjer kdohvata elemenata tipa podataka float4
\end_layout

\begin_layout Plain Layout

        // (vektor.x, vektor.y, vektor.z, vektor.w)
\end_layout

\begin_layout Plain Layout

        float invr = rsqrt(pown(d.x,2) + pown(d.y,2) + pown(d.z,2) + limit);
\end_layout

\begin_layout Plain Layout

        a += block[k].w * invr * invr * invr * d;
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // sinkronizacija za prelazak na sljedeći blok
\end_layout

\begin_layout Plain Layout

      barrier(CLK_LOCAL_MEM_FENCE);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // izračun nove pozicije i brzine
\end_layout

\begin_layout Plain Layout

    position += dt * velocity + 0.5f*dt*dt*a;
\end_layout

\begin_layout Plain Layout

    velocity += dt * a;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // osvježavanje podataka u globalnom nizu čestica
\end_layout

\begin_layout Plain Layout

    _position[g_tid] = position;
\end_layout

\begin_layout Plain Layout

    _velocity[g_tid] = velocity;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // sinkronizacija za sljedeću iteraciju
\end_layout

\begin_layout Plain Layout

    barrier(CLK_LOCAL_MEM_FENCE);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-N-body,-veličine"

\end_inset

.
 prikazuje odnos vremena izvođenja primjera ovisno o veličini bloka čestica
 odnosno veličini lokalnog indeksnog prostora 
\emph on
OpenCL
\emph default
-a.
 U primjeru množenja matrica je veličina lokalnog indeksnog prostora rasla
 kvadratom veličine bloka jer je problem bio dvodimenzionalan, dok je ovdje
 riječ o jednodimenzionalnom problemu, tj.
 čestice su smještene u jednodimenzionalan niz vektora.
 Očekivano je vrijeme izvođenja manje za veću veličinu bloka jer se više
 elemenata u jednom koraku kopira u bržu lokalnu memoriju.
 Svakako treba pripazi da se ne stavi prevelika veličina bloka iz razloga
 što je kod GPU-a lokalna memorija izuzetno mala, konkretno kod 
\emph on
Nvidie FX570m
\emph default
 svega 16kB za svaku radnu grupu.
 U primjeru se već kod veličine bloka od 512 rušio program, ali to nije
 ni toliko bitno, jer se već kod veličina većih od 32 ne postiže brže izvođenje
 primjera.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/opencl-nbody-blocks.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL,-N-body,-veličine"

\end_inset

OpenCL
\emph default
, 
\emph on
N-body
\emph default
, veličine lokalnih blokova
\end_layout

\end_inset


\end_layout

\end_inset

Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-N-body,-broj"

\end_inset

.
 prikazuje eksponencijalan rast trajanja izvođenja primjera ovisno o broju
 čestica.
 Rezultat je očekivan jer se za svaku česticu uzima utjecaj svih ostalih
 čestica, tako da je složenost O(n
\begin_inset Formula $^{\text{}2}$
\end_inset

).
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\emph on
\begin_inset Graphics
	filename gnuplot/opencl-nbody-dims.eps
	width 10cm

\end_inset


\emph default

\begin_inset Caption

\begin_layout Plain Layout

\emph on
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL,-N-body,-broj"

\end_inset

OpenCL
\emph default
, 
\emph on
N-body
\emph default
, broj čestica
\end_layout

\end_inset


\end_layout

\end_inset

Navedeni primjer je sam po sebi jednostavno paralelizirati, jer se radi
 o simulaciji velikog broja čestica nad kojima se obavljaju istovjetne operacije.
 Zanimljivo je korištenje vektorskih tipova podataka jer se postižu veće
 performanse
\begin_inset Foot
status open

\begin_layout Plain Layout
Mikroprocesor u jednom koraku obavi istu operaciju nad svim elementima vektora,
 kao da se radi o 
\emph on

\begin_inset Quotes eld
\end_inset

običnom
\begin_inset Quotes erd
\end_inset


\emph default
 tipu podataka podataka (
\emph on
integer
\emph default
, 
\emph on
float
\emph default
).
\end_layout

\end_inset

, naravno ako uređaj zna baratati sa njima, što je jedan od preduvjeta za
 
\emph on
OpenCL
\emph default
.
 Primjer također ilustrira općenitu praksu korištenja lokalne memorije kod
 
\emph on
OpenCL
\emph default
-a, neovisno o broju dimenzija problema.
\end_layout

\begin_layout Standard
Za daljnja ispitivanja bi bilo zanimljivo ostvariti neki kompleksniji algoritam
 u 
\emph on
OpenCL
\emph default
-u, koji se po svojoj prirodi teže paralelizira.
 
\emph on
OpenCL
\emph default
 u odnosu na druge sustave donekle olakšava paralelizaciju korištenjem indeksnog
 prostora i globalne i lokalne memorije, no njegova osnovna namjena je stvaranje
 apstrakcije nad heterogenim platformama.
 
\end_layout

\begin_layout Subsubsection
Odnos performansi OpenCL-a i OpenMP-a
\end_layout

\begin_layout Standard
Na slici 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL-FX570m-:"

\end_inset

 je zanimljiv omjer performansi množenja matrica u 
\emph on
OpenCL
\emph default
-u i 
\emph on
OpenMP
\emph default
-u.
 
\emph on
OpenCL
\emph default
 test je izveden na GPU-u 
\emph on
Nvidia FX570m
\emph default
 u prijenosnom računalu koristeći programsku jezgru primjera 3 sa veličinom
 grupe od osam, a 
\emph on
OpenMP
\emph default
 test na dva 
\emph on
Intel Xeon
\emph default
 CPU-a u poslužitelju.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/opencl-openmp.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL-FX570m-:"

\end_inset


\emph on
OpenCL FX570m
\emph default
 : 
\emph on
OpenMP
\emph default
 Marvin
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Iznenađujuće je da je GPU kroz 
\emph on
OpenCL
\emph default
 sa korištenjem lokalne memorije za kraće vrijeme izveo primjer od dva 
\emph on
Intel Xeona
\emph default
.
 Paralelna arhitektura GPU-a još više dolazi do izražaja kada se uzme u
 obzir da radi na daleko manjem radnom taktu, 
\emph on
FX570m
\emph default
 na 475Mhz spram 
\emph on
Xeona
\emph default
 na 2GHz, te da se navedeni GPU pojavio 2007.
 godine, dok je CPU arhitekture 
\shape italic
Nehalem
\shape default
 koju je 
\emph on
Intel
\emph default
 predstavio 2009.
 godine.
\end_layout

\begin_layout Standard
Dobiveni rezultat povlači za sobom pitanje je li se u svrhu računarstva
 visokih performansi (
\emph on
HPC
\emph default
) bolje oslanjati na GPU ili CPU.
 Prije svega treba uvidjeti o kakvom je problemu riječ, te odgovara li paralelna
 GPU arhitektura rješavanju tog problema.
 Ako je u pitanju jedoobrazna obrada velike količine podataka (
\shape italic
\emph on
engl.

\emph default
 stream processing
\shape default
) poput raznih simulacija, rada sa videom i 3D grafikom, može se sa velikom
 sigurnošću odlučiti za GPU.
 Naravno neizostavno je i trenutno stanje potpore 
\emph on
OpenCL
\emph default
-u ili nekom drugom 
\emph on
GP/GPU
\emph default
 sustavu, u praksi ono je trenutno jako malo zastupljeno za korisničke aplikacij
e
\begin_inset Foot
status open

\begin_layout Plain Layout
Za primjer se može uzeti aplikacija za uređivanje slika Photoshop CS4, kompanije
 Adobe, koja može koristiti i prednosti GPU-a u računalu.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Moguće je napraviti grubu usporedbu: 
\emph on
FX570m
\emph default
 posjeduje 4 multiprocesora i prema testovima postiže rezultate jednake
 kao dva 
\emph on
Xeon
\emph default
 CPU-a na 2GHz; dalje se za primjer može uzeti 
\emph on
Tesla
\emph default
 grafička kartica zadnje generacije koja posjeduje 4 grafička mikroprocesora
 svaki sa po 30 multiprocesora.
 
\emph on
Tesla
\emph default
 bi pod tom pretpostavkom trebala postići 30 puta bolje rezultate od 
\emph on
FX570m
\emph default
, a ako se uzme još dvostruko veći radni takt na kojem radi i 60 puta bolje
 rezultate.
 Naravno dio performansi se gubi porastom paralelizacije, ali znatno manji
 nego kod CPU-a.
 S druge strane je dovoljno pretpostaviti 120 
\emph on
Xeon
\emph default
 CPU-a koji bi teoretski trebali biti ekvivalent jednoj 
\emph on
Tesli
\emph default
 prema provedenim testovima.
 Naravno unutar jednog računala je nemoguće zamisliti 120 centralnih mikroproces
ora, već bi se trebalo računati na nekoliko poslužitelja, svaki sa po nekoliko
 CPU-a.
 Osim samih performansi postiže se i značajna financijska ušteda, te daleko
 manja potrošnja energije odnosno zagrijavanje.
\end_layout

\begin_layout Standard
Jedan od zaključaka ovog rada je da se svakako isplati odlučivati za GPU-ove,
 točnije investirati u matične ploče sa mogućnošću ugradnje jednog ili dva
 CPU-a za potrebe operacijskog sustava i raspodjele podataka, te što više
 
\emph on
PCIexpress x16
\emph default
 utora u koje se danas ugrađuju grafičke kartice sa pripadajućim GPU-ovima.
 Na taj način se ostavlja dovoljno prostora za kasnija eventualna proširenja
 ugradnjom dodatnih grafičkih kartica.
 Može se reći kako danas GPU novije generacije u stolnom računalu može nadmašiti
 računalnu moć nekoliko skupih poslužitelja sa x86 mikroprocesorima.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Primjere na 
\emph on
Apple Mac Mini
\emph default
 stolnom računalu nažalost nije bilo moguće provesti u potpunosti.
 Sustav se prilikom pokretanja primjera sa većim dimenzijama matrica na
 GPU-u rušio.
 Razlog je vjerovatno 
\shape italic

\begin_inset Quotes eld
\end_inset

slabiji
\begin_inset Quotes erd
\end_inset


\shape default
 grafički mikroprocesor koji dijeli radnu memoriju računala, te upaljeno
 grafičko sučelje (grafički poslužitelj 
\emph on
X
\emph default
) koje mu oduzima resurse.
 Drugi mogući razlog je još nedotjerana implementacija 
\emph on
OpenCL
\emph default
-a za dotičnu platformu ili pak što je manje vjerovatno greška u 
\emph on
pyOpenCL
\emph default
 sučelju koje nije pokazalo probleme na 
\emph on
GNU/Linuxu
\emph default
.
 Primjeri su pokrenuti na CPU-u, ali su rezultati pretjerano varirali ovisno
 o veličini dimenzija matrica, slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-CPU"

\end_inset

.
 Vjerovatan uzrok je operacijski sustav koji se izvodi na CPU-u i sama 
\emph on
OpenCL
\emph default
 implementacija.
 Također je čudno što je programska jezgra 3 postigla najlošije rezultate,
 a očekivano bi bilo da postigne najbolje jer koristi lokalnu memoriju koja
 bi trebala odgovarati brzoj priručnoj (engl.
 
\emph on
cache
\emph default
) memoriji CPU-a; ili možda ne? Kod svih ostalih rezultata, neovisno o korišteno
m sustavu, trajanje izvođenja primjera je eksponencijalno raslo u skladu
 sa veličinom matrica, a ovdje to nije slučaj.
 Moguć razlog je što manje veličine matrica zauzimaju naravno manje memorijskog
 prostora, pa iz toga razloga, neovisno o lokalnoj i globalnoj memoriji
 
\emph on
OpenCL
\emph default
-a, završe u priručnoj memoriji.
 CPU posjeduje priručnu memoriju veličine 4MB, a matrica veličine 512 zauzima
 1MB memorije, dok veličine 1024 zauzima 4MB memorije.
 Kako cijela matrica veličine 512 stane u priručnu memoriju, to je možda
 razlog velikog pada performansi za veće matrice.
 Moguće je i da se radi o izdvojenom slučaju, ali je svakako zanimljiva
 pojava koju bi trebalo dalje ispitati, za početak na nekoj drugoj implementacij
i koja podržava rad sa CPU-om poput 
\emph on
ATI Streama
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gnuplot/opencl-cpu.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCL,-CPU"

\end_inset

OpenCL, CPU
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Primjeri na prijenosnom računalu 
\emph on
thinkpad t61p
\emph default
 su izvedeni pod 
\emph on
GNU/Linux
\emph default
 operacijskim sustavom sa ugašenim grafičkim sučeljem (
\emph on
Xorg
\emph default
 poslužitelj).
 Korištena je dostupna 
\emph on
OpenCL
\emph default
 implementacija od 
\emph on
Nvidie
\emph default
 koja je još uvijek u fazi testiranja.
 Osim navedenih bilo bi zanimljivo isprobati 
\emph on
OpenCL
\emph default
 implementaciju kompanije 
\emph on
AMD/ATI
\emph default
, posebno iz razloga što podržava 
\emph on
Radeon
\emph default
 GPU-ove i u kombinaciji sa njima x86 CPU-ove.
 Također bi daljna istraživanja trebala ići u smjeru ostvarivanja raznovrsnijih
 algoritama u 
\emph on
OpenCL
\emph default
-u, prepisivanja dijela korisničkih aplikacija, te nekih dodatnih optimizacija
 u samom 
\emph on
OpenCL
\emph default
-u poput izbjegavanja konflikata prilikom pristupa memorijskim područjima
 i uključivanja optimizacija 
\emph on
OpenCL
\emph default
 prevodiocu.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Zaključak
\end_layout

\begin_layout Standard
Na temelju provedenog istraživanja mogu se postaviti dva zaključka: jedan
 vezan uz 
\emph on
OpenCL
\emph default
 kao sustav, a drugi uz razvoj heterogenih platforma u smislu arhitektura
 mikroprocesora.
 
\emph on
OpenCL
\emph default
 je prvi sustav koji omogućuje izvođenje istog programskog koda na različitim
 platformama, a njegova primjena može varirati od korisničkih aplikacija
 pa sve do računarstva visokih performansi.
 Danas na raspolaganju imamo mikroprocesore različitih arhitektura i svrha,
 te se nameće pitanje kako ih što jednostavnije i bolje iskoristiti.
\end_layout

\begin_layout Standard

\emph on
OpenCL
\emph default
 kao sustav za sada omogućuje iskorištavanje CPU-a i GPU-a koje danas nalazimo
 u svim osobnim računalima.
 Kako je riječ o novom sustavu, njegova implementacija na svim operacijskim
 sustavima i platformama se ne može smatrati potpunom za neku širu upotrebu
 u korisničkim aplikacijama.
 Kao standard iznimno obećava, te su između ostalog u njemu sudjelovale
 sve relevantije kompanije, pa se može zaključiti kako će njegova dostupnost
 sa vremenom rasti, tj.
 ako se želimo ograničiti na GPU-ove ona je već dostupna od 
\emph on
Nvidie
\emph default
 i 
\emph on
ATI
\emph default
-a za sve bitne operacijske sustave.
 Trenutno je raspoloživo izuzetno malo aplikacija koje koriste 
\emph on
GP/GPU
\emph default
, a uz 
\emph on
OpenCL
\emph default
 gotovo nijedna, no taj će se broj sa vremenom sigurno povećavati.
 
\emph on
OpenCL
\emph default
 je sustav koji prvi koji stvara apstrakciju nad različitim platformama
 i nije standard koji ovisi o jednom proizvođaču, tako da se može pretpostaviti
 da će se proizvođači korisničkih aplikacija u području simulacija, obrade
 zvuka, slike i videa odlučivati za njega.
 S druge strane, pruža visoke performanse tako da je primjenjiv i u području
 računarstva visokih performansi.
 Tu mu se kao nedostatak može nametnuti nepostojanje definicije mrežne komunikac
ije u standardu, ali kako je 
\emph on
HPC
\emph default
 specifično područje tako taj nedostatak ne bi trebao stvarati veću zapreku.
 Također mu je prednost što se kod 
\emph on
HPC
\emph default
-a često znaju koristiti različite platforme za koje je on upravo i namijenjen.
 
\end_layout

\begin_layout Standard
Drugi zaključak je vezan uz razvoj mikroprocesora.
 Sa korisničke strane je neophodno da svaki novi mikroprocesor pruža kompatibiln
ost unatrag (x86 arhitektura), ali to ne sprečava daljni razvoj u pogledu
 povećanja višejezgrenosti i uključivanja jezgri specifičnije namjene u
 mikroprocesore.
 Taj trend se već može iščitati po najavama proizvođača mikroprocesora.
 Također je danas moguće imati jedan ili više mikroprocesora opće namjene
 i uz njih razne akceleratorske mikroprocesore poput GPU-a.
 Kod 
\emph on
HPC
\emph default
-a taj problem unazadne kompatibilnosti nije toliko izražen zbog specifičnosti
 same namjene 
\emph on
HPC
\emph default
-a.
 Ako se danas odlučujemo za izgradnju paralelnog računala svakako se treba
 odstupiti od dosadašnje prakse pukog gomilanja CPU-a, već se orijentirati
 i na druge arhitekture poput GPU-a i 
\emph on
Cell
\emph default
-a.
\end_layout

\begin_layout Standard
Konačno je za same korisnike dobro što danas za malu cijenu mogu dobiti
 poprilično jako osobno računalo za koje će kroz dogledno vrijeme biti dostupne
 uobičajene aplikacije, ali sa mogućnošću iskorištavanja paraleliziranih
 arhitektura.
 Programeri, znanstvena zajednica i napredniji korisnici danas mogu iskorištavat
i puni potencijal heterogenih platformi kroz sustav 
\emph on
OpenCL
\emph default
 za svoje specifične ciljeve.
 Time se 
\emph on
OpenCL
\emph default
 kao standard iznimno dobro uklopio na trenutno dostupne platforme, ali
 i one koje će se tek pojaviti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Ključne riječi: paralelizacija algoritama, heterogene platforme, 
\emph on
OpenCL
\emph default
, 
\emph on
GP/GPU
\emph default
, 
\emph on
MPI
\emph default
, 
\emph on
OpenMP
\emph default
, centralni/grafički mikroprocesor, 
\emph on
Cell/BE
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Keywords: parallel algorithms, heterogeneous platforms, 
\emph on
OpenCL
\emph default
, 
\emph on
GP/GPU
\emph default
, 
\emph on
MPI
\emph default
, 
\emph on
OpenMP
\emph default
, CPU, GPU, 
\emph on
Cell/BE
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Dodatak: Tablični prikaz rezultata primjera
\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenMP,-različiti-rangovi"

\end_inset

.) 
\emph on
OpenMP
\emph default
, različite veličine matrica na Marvinu
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
OpenMP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.28
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
17.39
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2.17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
76.62
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
9.17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2048
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
197.78
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
25.84
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenMP,-različiti-tipovi"

\end_inset

.) 
\emph on
OpenMP
\emph default
, različiti tipovi podataka na Marvinu 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
double
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.07
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.07
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.22
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.30
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2.12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2.17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
3.52
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
9.30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
9.17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
13.92
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2048
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
27.71
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
25.84
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
36.51
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MPI,-različiti-rangovi"

\end_inset

.) 
\emph on
MPI
\emph default
, različite veličine matrica i brojevi procesa na Marvinu 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.089
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.045
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.030
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.029
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.794
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.402
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.276
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.216
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 4.351
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
10.092
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 6.223
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 4.639
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 56.763
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
27.741
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
19.719
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
14.222
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2048
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
139.930
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
73.83
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
52.833
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
42.248
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenMP---MPI,"

\end_inset

.) 
\emph on
OpenMP
\emph default
 - 
\emph on
MPI
\emph default
, Marvin 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
OpenMP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
MPI, 8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.07
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.029
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.216
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2.17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 4.639
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
9.17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
14.222
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2048
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
25.84
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
42.248
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka"

\end_inset

.) 
\emph on
OpenCL
\emph default
, veličina bloka 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.652
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.651
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 1.020
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 4.934
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 4.933
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 8.138
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 40.634
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 45.598
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
122.875
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
271.867
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
271.771
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
415.517
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka-4"

\end_inset

.) 
\emph on
OpenCL
\emph default
, veličina bloka 4
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.166
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.248
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.061
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 1.984
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 1.984
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.484
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
15.867
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
15.867
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 3.903
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
51.139
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
51.177
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
13.202
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka-8"

\end_inset

.) 
\emph on
OpenCL
\emph default
, veličina bloka 8
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.140
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.140
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.015
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 1.123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 1.122
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.121
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 9.332
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
14.968
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.934
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
53.297
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
53.565
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
6.520
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-veličina-bloka-16"

\end_inset

.) OpenCL, veličina bloka 16
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.222 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.243
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.039
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 1.989
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 1.959
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.312
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
15.792
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
15.760
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2.503
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
54.227
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
54.708
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8.462
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-usporedba-tipova"

\end_inset

.) 
\emph on
OpenCL
\emph default
, usporedba tipova podataka
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
integer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.015 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.016
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.121
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.132
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.934
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.056
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
6.520
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
7.122
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-N-body,-veličine"

\end_inset

.) 
\emph on
OpenCL
\emph default
, 
\emph on
N-body
\emph default
, veličine lokalnih blokova; čestice 1024, iteracije 128 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Blok
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Trajanje
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4.982
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.858
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.778
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.350
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.177
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.111
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-N-body,-broj"

\end_inset

.) 
\emph on
OpenCL
\emph default
, 
\emph on
N-body
\emph default
, broj čestica 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Broj čestica
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Trajanje
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.167
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.445
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2048
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.780
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4096
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
7.117
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL-FX570m-:"

\end_inset

.) 
\emph on
OpenCL FX570m
\emph default
 : 
\emph on
OpenMP
\emph default
 Marvin
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
OpenCL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
OpenMP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.015
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.121
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.28
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.934
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2.17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
6.520
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
9.17
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Caption

\begin_layout Plain Layout
(Slika 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCL,-CPU"

\end_inset

.) 
\emph on
OpenCL
\emph default
, CPU
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Veličina
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Jezgra 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.040
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.040
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.099
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.548
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.545
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
 0.869
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
25.980
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
25.760
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
31.319
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
29.237
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
28.278
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
39.716
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\size default

\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

Khronos OpenCL Working Group, 2009: The OpenCL Specification, version 1.0
 rev 48
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

Nvidia, 2009: OpenCL Programming for the CUDA Architecture, version 2.3 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

Nvidia, 2009: OpenCL Programming Guide for the CUDA Architecture, version
 2.3 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-4"

\end_inset

Nvidia, 2009: OpenCL Best Practices Guide, version 1.0
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-9"

\end_inset

Andreas Klöckner, prosinac 2009: http://mathema.tician.de/software/pyopencl/
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-10"

\end_inset

Wikipedia, 12.02.2010: http://en.wikipedia.org/wiki/N-body_problem
\end_layout

\end_body
\end_document
